# Tool Registry Browser - Complete MVVM Architecture Design Document

## Executive Summary

### Project Overview
Complete rebuild of the Tool Registry Browser application using professional MVVM (Model-View-ViewModel) architecture, Umbilical Component Protocol, and responsive design principles. This document serves as the complete technical specification for creating a maintainable, scalable, and fully responsive tool management interface.

### Why Rebuild?
The current implementation suffers from critical architectural issues:
- Hardcoded HTML mixed with component logic
- Inline styles preventing responsive design
- Lack of proper component separation
- No standardized component protocol
- Fixed pixel values preventing fluid responsiveness

### Project Goals
- **Professional Architecture**: Implement strict MVVM separation in all components
- **Zero Hardcoded HTML**: All markup generated dynamically by component View layers
- **CSS Classes Only**: Eliminate all inline styles throughout the system
- **Full Responsiveness**: Fluid design using clamp(), vh, vw, rem (no pixels)
- **Component Protocol**: All components follow Umbilical Protocol standard
- **Maintainable Codebase**: Clear separation of concerns and standardized patterns

## Core Architecture Principles

### 1. MVVM Architecture Requirements
Every component must implement strict Model-View-ViewModel separation:

```javascript
// Required pattern for all components
export const ComponentName = {
  create(umbilical) {
    // Umbilical protocol compliance
    if (umbilical.describe) { /* introspection */ }
    if (umbilical.validate) { /* validation */ }
    
    // MVVM layers
    const model = new ComponentModel();
    const view = new ComponentView(umbilical.dom);
    const viewModel = new ComponentViewModel(model, view);
    
    return viewModel.initialize();
  }
};
```

### 2. Zero Hardcoded HTML Rule
**FORBIDDEN**: Any HTML in main application files
```javascript
// ‚ùå NEVER DO THIS
app.innerHTML = `<div class="header">...</div>`;
```

**REQUIRED**: All HTML generated by component View layers
```javascript
// ‚úÖ CORRECT APPROACH
class ComponentView {
  render(modelData) {
    const element = document.createElement('div');
    element.className = 'component-container';
    return this.buildStructure(element, modelData);
  }
}
```

### 3. CSS Classes Only Rule
**FORBIDDEN**: Any inline styles anywhere
```javascript
// ‚ùå NEVER DO THIS
element.style.padding = '20px';
element.setAttribute('style', 'color: red;');
```

**REQUIRED**: CSS classes with responsive design
```javascript
// ‚úÖ CORRECT APPROACH
element.className = 'responsive-container';
// With CSS: .responsive-container { padding: clamp(1rem, 3vw, 2rem); }
```

### 4. Responsive Design Philosophy
**Core Principle**: Everything scales fluidly without media queries
- **Typography**: `font-size: clamp(0.875rem, 2.5vw, 1.125rem)`
- **Spacing**: `padding: clamp(1rem, 3vh, 2rem) clamp(1rem, 4vw, 3rem)`
- **Layout**: Flexbox and CSS Grid with fractional units
- **Components**: Scale proportionally to viewport

### 5. Umbilical Protocol Compliance
All components must support three operational modes:
```javascript
// 1. Introspection Mode
Component.create({ describe: (requirements) => {...} });

// 2. Validation Mode  
Component.create({ validate: (testUmbilical) => {...} });

// 3. Instance Mode
Component.create({ dom: element, ...capabilities });
```

## Component Architecture Specifications

### System Component Hierarchy
```
ToolRegistryBrowser (Root Application)
‚îú‚îÄ‚îÄ ApplicationHeader
‚îÇ   ‚îú‚îÄ‚îÄ AppTitle
‚îÇ   ‚îú‚îÄ‚îÄ AppDescription  
‚îÇ   ‚îî‚îÄ‚îÄ GlobalSearch (future)
‚îú‚îÄ‚îÄ NavigationTabs
‚îÇ   ‚îú‚îÄ‚îÄ TabButton (multiple)
‚îÇ   ‚îî‚îÄ‚îÄ TabContentArea
‚îî‚îÄ‚îÄ PanelRenderer
    ‚îú‚îÄ‚îÄ ToolSearchPanel
    ‚îÇ   ‚îú‚îÄ‚îÄ SearchControls
    ‚îÇ   ‚îú‚îÄ‚îÄ FilterControls
    ‚îÇ   ‚îî‚îÄ‚îÄ ResultsGrid
    ‚îú‚îÄ‚îÄ ModuleBrowserPanel
    ‚îÇ   ‚îú‚îÄ‚îÄ ModuleTree
    ‚îÇ   ‚îú‚îÄ‚îÄ ModuleDetails
    ‚îÇ   ‚îî‚îÄ‚îÄ ToolsList
    ‚îú‚îÄ‚îÄ ToolDetailsPanel
    ‚îÇ   ‚îú‚îÄ‚îÄ ToolOverview
    ‚îÇ   ‚îú‚îÄ‚îÄ SchemaVisualization
    ‚îÇ   ‚îî‚îÄ‚îÄ Documentation
    ‚îî‚îÄ‚îÄ AdministrationPanel
        ‚îú‚îÄ‚îÄ UserManagement
        ‚îú‚îÄ‚îÄ SystemSettings
        ‚îî‚îÄ‚îÄ DataImport
```

## Detailed Component Specifications

### 1. ToolRegistryBrowser (Root Component)

#### Purpose
Main application container that coordinates all child components and manages global application state.

#### File Structure
```
/src/components/tool-registry/
‚îú‚îÄ‚îÄ index.js                    # Main component export
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îî‚îÄ‚îÄ ToolRegistryModel.js   # Application state management
‚îú‚îÄ‚îÄ view/
‚îÇ   ‚îî‚îÄ‚îÄ ToolRegistryView.js    # DOM structure and CSS classes
‚îî‚îÄ‚îÄ viewmodel/
    ‚îî‚îÄ‚îÄ ToolRegistryViewModel.js # Coordination logic
```

#### Model Layer
```javascript
// /src/components/tool-registry/model/ToolRegistryModel.js
export class ToolRegistryModel {
  constructor() {
    this.state = {
      // Application State
      currentPanel: 'search',
      isLoading: false,
      errorState: null,
      connectionStatus: 'disconnected',
      
      // Data State
      tools: new Map(),
      modules: new Map(), 
      searchResults: [],
      selectedTool: null,
      selectedModule: null,
      
      // UI State
      windowDimensions: { width: 0, height: 0 },
      activeFilters: {},
      userPreferences: {
        theme: 'light',
        defaultView: 'search',
        itemsPerPage: 20
      }
    };
    
    // Event system for component communication
    this.eventEmitter = new EventTarget();
    this.subscriptions = new Map();
  }
  
  // State management methods
  updateState(path, value) {
    const oldValue = this.getState(path);
    this.setNestedProperty(this.state, path, value);
    this.emit('stateChanged', { path, value, oldValue });
  }
  
  getState(path) {
    return this.getNestedProperty(this.state, path);
  }
  
  subscribe(path, callback) {
    if (!this.subscriptions.has(path)) {
      this.subscriptions.set(path, new Set());
    }
    this.subscriptions.get(path).add(callback);
    
    return () => this.subscriptions.get(path)?.delete(callback);
  }
  
  emit(eventType, data) {
    this.eventEmitter.dispatchEvent(new CustomEvent(eventType, { detail: data }));
  }
}
```

#### View Layer
```javascript
// /src/components/tool-registry/view/ToolRegistryView.js
export class ToolRegistryView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
    this.elements = new Map();
  }
  
  generateCSS() {
    return `
      /* CSS Variables for Responsive Design */
      :root {
        /* Spacing System */
        --spacing-xs: clamp(0.25rem, 1vw, 0.5rem);
        --spacing-sm: clamp(0.5rem, 2vw, 1rem);
        --spacing-md: clamp(1rem, 3vw, 2rem);
        --spacing-lg: clamp(2rem, 5vw, 4rem);
        --spacing-xl: clamp(3rem, 8vw, 6rem);
        
        /* Typography System */
        --font-xs: clamp(0.75rem, 2vw, 0.875rem);
        --font-sm: clamp(0.875rem, 2.5vw, 1rem);
        --font-md: clamp(1rem, 3vw, 1.25rem);
        --font-lg: clamp(1.25rem, 4vw, 2rem);
        --font-xl: clamp(2rem, 6vw, 3rem);
        --font-xxl: clamp(2.5rem, 8vw, 4rem);
        
        /* Color System */
        --color-primary: #3b82f6;
        --color-primary-hover: #2563eb;
        --color-secondary: #64748b;
        --color-success: #10b981;
        --color-warning: #f59e0b;
        --color-error: #ef4444;
        
        --surface-primary: #ffffff;
        --surface-secondary: #f8fafc;
        --surface-tertiary: #f1f5f9;
        --surface-hover: #e2e8f0;
        
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --text-tertiary: #94a3b8;
        
        --border-subtle: #e2e8f0;
        --border-medium: #cbd5e1;
        --border-strong: #94a3b8;
        
        /* Shadows */
        --shadow-sm: 0 0.0625rem 0.125rem rgba(0, 0, 0, 0.1);
        --shadow-md: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.15);
        
        /* Border Radius */
        --radius-sm: clamp(0.25rem, 0.5vw, 0.375rem);
        --radius-md: clamp(0.375rem, 1vw, 0.5rem);
        --radius-lg: clamp(0.5rem, 1.5vw, 0.75rem);
      }
      
      /* Root Application Styles */
      .tool-registry-app {
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: var(--surface-secondary);
        color: var(--text-primary);
        line-height: 1.6;
      }
      
      /* Header Section */
      .app-header {
        flex-shrink: 0;
        background: var(--surface-primary);
        border-bottom: 0.125rem solid var(--border-subtle);
        box-shadow: var(--shadow-sm);
      }
      
      /* Main Content Area */
      .main-content {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      /* Loading States */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      
      .loading-spinner {
        width: clamp(2rem, 5vw, 3rem);
        height: clamp(2rem, 5vw, 3rem);
        border: 0.25rem solid var(--border-subtle);
        border-top: 0.25rem solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* Error States */
      .error-container {
        padding: var(--spacing-lg);
        text-align: center;
        color: var(--color-error);
      }
      
      .error-title {
        font-size: var(--font-lg);
        font-weight: 600;
        margin-bottom: var(--spacing-md);
      }
      
      .error-message {
        font-size: var(--font-md);
        margin-bottom: var(--spacing-lg);
      }
      
      /* Utility Classes */
      .visually-hidden {
        position: absolute;
        width: 0.0625rem;
        height: 0.0625rem;
        padding: 0;
        margin: -0.0625rem;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      
      .scroll-container {
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--border-medium) transparent;
      }
      
      .scroll-container::-webkit-scrollbar {
        width: 0.5rem;
      }
      
      .scroll-container::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .scroll-container::-webkit-scrollbar-thumb {
        background: var(--border-medium);
        border-radius: var(--radius-sm);
      }
      
      .scroll-container::-webkit-scrollbar-thumb:hover {
        background: var(--border-strong);
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    // Clear container
    this.container.innerHTML = '';
    this.container.className = 'tool-registry-app';
    
    // Create main structure
    const headerContainer = this.createHeaderContainer();
    const mainContent = this.createMainContent();
    
    this.container.appendChild(headerContainer);
    this.container.appendChild(mainContent);
    
    // Store element references
    this.elements.set('header', headerContainer);
    this.elements.set('main', mainContent);
    
    return this.container;
  }
  
  createHeaderContainer() {
    const header = document.createElement('div');
    header.className = 'app-header';
    header.id = 'app-header-container';
    return header;
  }
  
  createMainContent() {
    const main = document.createElement('div');
    main.className = 'main-content';
    main.id = 'main-content-container';
    return main;
  }
  
  showLoading() {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = '<div class="loading-spinner"></div>';
    this.container.appendChild(overlay);
  }
  
  hideLoading() {
    const overlay = this.container.querySelector('.loading-overlay');
    if (overlay) {
      overlay.remove();
    }
  }
  
  showError(error) {
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-container';
    errorContainer.innerHTML = `
      <h2 class="error-title">Application Error</h2>
      <p class="error-message">${error.message || 'An unexpected error occurred'}</p>
    `;
    
    const main = this.elements.get('main');
    main.innerHTML = '';
    main.appendChild(errorContainer);
  }
}
```

#### ViewModel Layer
```javascript
// /src/components/tool-registry/viewmodel/ToolRegistryViewModel.js
export class ToolRegistryViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    
    // Child components
    this.components = new Map();
    
    // WebSocket connection
    this.websocket = null;
    
    // Cleanup functions
    this.cleanupFunctions = [];
  }
  
  async initialize() {
    try {
      // Show loading state
      this.view.showLoading();
      
      // Render initial structure
      this.view.render(this.model.getState());
      
      // Initialize WebSocket connection
      await this.initializeWebSocket();
      
      // Load child components
      await this.loadChildComponents();
      
      // Set up event listeners
      this.setupEventListeners();
      
      // Load initial data
      await this.loadInitialData();
      
      // Hide loading state
      this.view.hideLoading();
      
      // Notify parent of successful mount
      if (this.umbilical.onMount) {
        this.umbilical.onMount(this.createPublicAPI());
      }
      
      return this.createPublicAPI();
      
    } catch (error) {
      this.view.hideLoading();
      this.view.showError(error);
      console.error('ToolRegistryBrowser initialization failed:', error);
      throw error;
    }
  }
  
  async initializeWebSocket() {
    if (!this.umbilical.websocketUrl) return;
    
    try {
      const { WebSocketManager } = await import('./utils/WebSocketManager.js');
      this.websocket = new WebSocketManager(this.umbilical.websocketUrl);
      
      await this.websocket.connect();
      this.setupWebSocketListeners();
      
      this.model.updateState('connectionStatus', 'connected');
      
    } catch (error) {
      console.warn('WebSocket connection failed:', error);
      this.model.updateState('connectionStatus', 'failed');
    }
  }
  
  setupWebSocketListeners() {
    this.websocket.subscribe('tools.updated', (data) => {
      this.handleToolsUpdate(data);
    });
    
    this.websocket.subscribe('modules.updated', (data) => {
      this.handleModulesUpdate(data);
    });
    
    this.websocket.subscribe('system.status', (data) => {
      this.handleSystemStatus(data);
    });
  }
  
  async loadChildComponents() {
    // Load ApplicationHeader
    const { ApplicationHeader } = await import('./components/ApplicationHeader.js');
    const headerContainer = document.getElementById('app-header-container');
    
    this.components.set('header', ApplicationHeader.create({
      dom: headerContainer,
      title: 'üõ†Ô∏è Legion Tool Registry',
      subtitle: 'Professional tool management and discovery platform',
      onMount: () => console.log('ApplicationHeader mounted')
    }));
    
    // Load NavigationTabs
    const { NavigationTabs } = await import('./components/NavigationTabs.js');
    const mainContainer = document.getElementById('main-content-container');
    
    this.components.set('navigation', NavigationTabs.create({
      dom: mainContainer,
      tabs: [
        { id: 'search', title: 'üîç Tool Search', component: 'ToolSearchPanel' },
        { id: 'modules', title: 'üì¶ Module Browser', component: 'ModuleBrowserPanel' },
        { id: 'details', title: 'üìã Tool Details', component: 'ToolDetailsPanel' },
        { id: 'admin', title: '‚öôÔ∏è Administration', component: 'AdministrationPanel' }
      ],
      activeTab: this.model.getState('currentPanel'),
      onTabChange: (tabId) => this.handleTabChange(tabId),
      onMount: () => console.log('NavigationTabs mounted')
    }));
  }
  
  handleTabChange(tabId) {
    this.model.updateState('currentPanel', tabId);
    
    if (this.umbilical.onTabChange) {
      this.umbilical.onTabChange(tabId, { title: this.getTabTitle(tabId) });
    }
  }
  
  setupEventListeners() {
    // Window resize handling
    const handleResize = () => {
      this.model.updateState('windowDimensions', {
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    this.cleanupFunctions.push(() => window.removeEventListener('resize', handleResize));
    
    // State change listeners
    const unsubscribe = this.model.subscribe('currentPanel', (newPanel) => {
      this.loadPanelComponent(newPanel);
    });
    this.cleanupFunctions.push(unsubscribe);
  }
  
  async loadInitialData() {
    // Load tools and modules data
    if (this.websocket) {
      this.websocket.publish('data.request', {
        type: 'initial_load',
        includes: ['tools', 'modules', 'user_preferences']
      });
    }
  }
  
  createPublicAPI() {
    return {
      // State management
      getState: (path) => this.model.getState(path),
      updateState: (path, value) => this.model.updateState(path, value),
      
      // Navigation
      switchToPanel: (panelId) => this.handleTabChange(panelId),
      getCurrentPanel: () => this.model.getState('currentPanel'),
      
      // Data access
      getTools: () => this.model.getState('tools'),
      getModules: () => this.model.getState('modules'),
      
      // Component access
      getComponent: (name) => this.components.get(name),
      
      // Cleanup
      destroy: () => this.destroy()
    };
  }
  
  destroy() {
    // Run all cleanup functions
    this.cleanupFunctions.forEach(cleanup => cleanup());
    
    // Destroy child components
    this.components.forEach(component => {
      if (component.destroy) {
        component.destroy();
      }
    });
    
    // Close WebSocket connection
    if (this.websocket) {
      this.websocket.disconnect();
    }
    
    // Clear DOM
    this.view.container.innerHTML = '';
    
    // Notify parent of destruction
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}
```

#### Main Component Export
```javascript
// /src/components/tool-registry/index.js
import { UmbilicalUtils } from '../../umbilical/index.js';
import { ToolRegistryModel } from './model/ToolRegistryModel.js';
import { ToolRegistryView } from './view/ToolRegistryView.js';
import { ToolRegistryViewModel } from './viewmodel/ToolRegistryViewModel.js';

export const ToolRegistryBrowser = {
  create(umbilical) {
    // 1. Introspection Mode
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element for the application');
      requirements.add('websocketUrl', 'string', 'WebSocket URL for real-time data (optional)', false);
      requirements.add('onMount', 'function', 'Callback when application is mounted (optional)', false);
      requirements.add('onDestroy', 'function', 'Callback when application is destroyed (optional)', false);
      requirements.add('onTabChange', 'function', 'Callback when navigation tab changes (optional)', false);
      requirements.add('onError', 'function', 'Callback for error handling (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    // 2. Validation Mode
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE,
        hasValidWebSocketUrl: !umbilical.websocketUrl || typeof umbilical.websocketUrl === 'string'
      });
    }
    
    // 3. Instance Creation Mode
    UmbilicalUtils.validateCapabilities(umbilical, ['dom'], 'ToolRegistryBrowser');
    
    // Create MVVM layers
    const model = new ToolRegistryModel();
    const view = new ToolRegistryView(umbilical.dom);
    const viewModel = new ToolRegistryViewModel(model, view, umbilical);
    
    // Initialize and return public API
    return viewModel.initialize();
  }
};
```

### 2. ApplicationHeader Component

#### Purpose
Displays application title, subtitle, and global controls like search and user management.

#### File Structure
```
/src/components/tool-registry/components/
‚îî‚îÄ‚îÄ ApplicationHeader.js
```

#### Complete Implementation
```javascript
// /src/components/tool-registry/components/ApplicationHeader.js
import { UmbilicalUtils } from '../../../umbilical/index.js';

class ApplicationHeaderModel {
  constructor(options = {}) {
    this.state = {
      title: options.title || 'Application',
      subtitle: options.subtitle || '',
      showSearch: options.showSearch !== false,
      searchQuery: '',
      userInfo: options.userInfo || null
    };
  }
  
  updateState(path, value) {
    const keys = path.split('.');
    let current = this.state;
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
  }
  
  getState(path = '') {
    if (!path) return this.state;
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }
}

class ApplicationHeaderView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
  }
  
  generateCSS() {
    return `
      .app-header-container {
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--surface-primary);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: var(--spacing-md);
        min-height: clamp(4rem, 12vh, 6rem);
      }
      
      .header-main-content {
        flex: 1;
        min-width: clamp(20rem, 40vw, 30rem);
      }
      
      .app-title {
        font-size: var(--font-xl);
        font-weight: 700;
        margin: 0 0 var(--spacing-xs) 0;
        color: var(--text-primary);
        line-height: 1.2;
      }
      
      .app-subtitle {
        font-size: var(--font-md);
        color: var(--text-secondary);
        margin: 0;
        line-height: 1.4;
      }
      
      .header-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        flex-shrink: 0;
      }
      
      .global-search-container {
        position: relative;
        min-width: clamp(15rem, 25vw, 20rem);
      }
      
      .global-search-input {
        width: 100%;
        padding: var(--spacing-sm) var(--spacing-md);
        padding-left: clamp(2.5rem, 6vw, 3rem);
        font-size: var(--font-sm);
        border: 0.125rem solid var(--border-subtle);
        border-radius: var(--radius-md);
        background: var(--surface-secondary);
        color: var(--text-primary);
        transition: all 0.2s ease;
      }
      
      .global-search-input:focus {
        outline: none;
        border-color: var(--color-primary);
        box-shadow: 0 0 0 0.1875rem rgba(59, 130, 246, 0.15);
        background: var(--surface-primary);
      }
      
      .global-search-input::placeholder {
        color: var(--text-tertiary);
      }
      
      .search-icon {
        position: absolute;
        left: var(--spacing-sm);
        top: 50%;
        transform: translateY(-50%);
        width: clamp(1rem, 2.5vw, 1.25rem);
        height: clamp(1rem, 2.5vw, 1.25rem);
        color: var(--text-tertiary);
        pointer-events: none;
      }
      
      .user-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }
      
      .user-avatar {
        width: clamp(2rem, 5vw, 2.5rem);
        height: clamp(2rem, 5vw, 2.5rem);
        border-radius: 50%;
        background: var(--color-primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: var(--font-sm);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .user-avatar:hover {
        background: var(--color-primary-hover);
        transform: scale(1.05);
      }
      
      .notifications-button {
        padding: var(--spacing-sm);
        background: transparent;
        border: 0.125rem solid var(--border-subtle);
        border-radius: var(--radius-sm);
        cursor: pointer;
        color: var(--text-secondary);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .notifications-button:hover {
        border-color: var(--color-primary);
        color: var(--color-primary);
        background: rgba(59, 130, 246, 0.05);
      }
      
      @media (max-width: 48rem) {
        .app-header-container {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }
        
        .header-controls {
          justify-content: center;
          flex-wrap: wrap;
        }
        
        .global-search-container {
          min-width: 100%;
        }
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    this.container.innerHTML = '';
    this.container.className = 'app-header-container';
    
    // Main content (title and subtitle)
    const mainContent = this.createMainContent(modelData);
    this.container.appendChild(mainContent);
    
    // Controls (search and user)
    if (modelData.showSearch || modelData.userInfo) {
      const controls = this.createHeaderControls(modelData);
      this.container.appendChild(controls);
    }
    
    return this.container;
  }
  
  createMainContent(modelData) {
    const mainContent = document.createElement('div');
    mainContent.className = 'header-main-content';
    
    const title = document.createElement('h1');
    title.className = 'app-title';
    title.textContent = modelData.title;
    
    const subtitle = document.createElement('p');
    subtitle.className = 'app-subtitle';
    subtitle.textContent = modelData.subtitle;
    
    mainContent.appendChild(title);
    if (modelData.subtitle) {
      mainContent.appendChild(subtitle);
    }
    
    return mainContent;
  }
  
  createHeaderControls(modelData) {
    const controls = document.createElement('div');
    controls.className = 'header-controls';
    
    // Global search
    if (modelData.showSearch) {
      const searchContainer = this.createSearchControl(modelData);
      controls.appendChild(searchContainer);
    }
    
    // User controls
    if (modelData.userInfo) {
      const userControls = this.createUserControls(modelData);
      controls.appendChild(userControls);
    }
    
    return controls;
  }
  
  createSearchControl(modelData) {
    const container = document.createElement('div');
    container.className = 'global-search-container';
    
    const searchIcon = document.createElement('div');
    searchIcon.className = 'search-icon';
    searchIcon.innerHTML = 'üîç';
    
    const input = document.createElement('input');
    input.className = 'global-search-input';
    input.type = 'text';
    input.placeholder = 'Search tools, modules, or documentation...';
    input.value = modelData.searchQuery || '';
    
    container.appendChild(searchIcon);
    container.appendChild(input);
    
    return container;
  }
  
  createUserControls(modelData) {
    const controls = document.createElement('div');
    controls.className = 'user-controls';
    
    // Notifications button
    const notificationsButton = document.createElement('button');
    notificationsButton.className = 'notifications-button';
    notificationsButton.innerHTML = 'üîî';
    notificationsButton.title = 'Notifications';
    
    // User avatar
    const avatar = document.createElement('div');
    avatar.className = 'user-avatar';
    avatar.textContent = modelData.userInfo?.initials || 'üë§';
    avatar.title = modelData.userInfo?.name || 'User Account';
    
    controls.appendChild(notificationsButton);
    controls.appendChild(avatar);
    
    return controls;
  }
}

class ApplicationHeaderViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    this.eventListeners = [];
  }
  
  initialize() {
    this.render();
    this.setupEventListeners();
    
    if (this.umbilical.onMount) {
      this.umbilical.onMount(this.createPublicAPI());
    }
    
    return this.createPublicAPI();
  }
  
  render() {
    this.view.render(this.model.getState());
  }
  
  setupEventListeners() {
    const searchInput = this.view.container.querySelector('.global-search-input');
    if (searchInput) {
      const handleSearch = (event) => {
        const query = event.target.value;
        this.model.updateState('searchQuery', query);
        
        if (this.umbilical.onSearch) {
          this.umbilical.onSearch(query);
        }
      };
      
      searchInput.addEventListener('input', handleSearch);
      this.eventListeners.push(() => searchInput.removeEventListener('input', handleSearch));
    }
    
    const userAvatar = this.view.container.querySelector('.user-avatar');
    if (userAvatar) {
      const handleUserClick = () => {
        if (this.umbilical.onUserClick) {
          this.umbilical.onUserClick();
        }
      };
      
      userAvatar.addEventListener('click', handleUserClick);
      this.eventListeners.push(() => userAvatar.removeEventListener('click', handleUserClick));
    }
  }
  
  createPublicAPI() {
    return {
      updateTitle: (title) => {
        this.model.updateState('title', title);
        this.render();
      },
      updateSubtitle: (subtitle) => {
        this.model.updateState('subtitle', subtitle);
        this.render();
      },
      getSearchQuery: () => this.model.getState('searchQuery'),
      clearSearch: () => {
        this.model.updateState('searchQuery', '');
        this.render();
      },
      destroy: () => this.destroy()
    };
  }
  
  destroy() {
    this.eventListeners.forEach(cleanup => cleanup());
    this.view.container.innerHTML = '';
    
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}

export const ApplicationHeader = {
  create(umbilical) {
    // Umbilical Protocol implementation
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element');
      requirements.add('title', 'string', 'Application title (optional)', false);
      requirements.add('subtitle', 'string', 'Application subtitle (optional)', false);
      requirements.add('showSearch', 'boolean', 'Show global search (optional)', false);
      requirements.add('userInfo', 'object', 'User information object (optional)', false);
      requirements.add('onMount', 'function', 'Mount callback (optional)', false);
      requirements.add('onSearch', 'function', 'Search callback (optional)', false);
      requirements.add('onUserClick', 'function', 'User click callback (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE
      });
    }
    
    UmbilicalUtils.validateCapabilities(umbilical, ['dom'], 'ApplicationHeader');
    
    const model = new ApplicationHeaderModel(umbilical);
    const view = new ApplicationHeaderView(umbilical.dom);
    const viewModel = new ApplicationHeaderViewModel(model, view, umbilical);
    
    return viewModel.initialize();
  }
};
```

### 3. NavigationTabs Component

#### Purpose
Responsive tab navigation system that manages content panels and handles tab switching with smooth transitions.

#### Complete Implementation
```javascript
// /src/components/tool-registry/components/NavigationTabs.js
import { UmbilicalUtils } from '../../../umbilical/index.js';

class NavigationTabsModel {
  constructor(options = {}) {
    this.state = {
      tabs: options.tabs || [],
      activeTab: options.activeTab || (options.tabs?.[0]?.id) || null,
      orientation: options.orientation || 'horizontal', // 'horizontal' | 'vertical'
      variant: options.variant || 'default', // 'default' | 'pills' | 'underline'
      showIcons: options.showIcons !== false,
      closableTabs: options.closableTabs || false
    };
  }
  
  updateState(path, value) {
    const keys = path.split('.');
    let current = this.state;
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
  }
  
  getState(path = '') {
    if (!path) return this.state;
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }
  
  getActiveTab() {
    return this.state.tabs.find(tab => tab.id === this.state.activeTab);
  }
  
  setActiveTab(tabId) {
    if (this.state.tabs.some(tab => tab.id === tabId)) {
      this.state.activeTab = tabId;
      return true;
    }
    return false;
  }
}

class NavigationTabsView {
  constructor(container) {
    this.container = container;
    this.cssInjected = false;
    this.elements = new Map();
  }
  
  generateCSS() {
    return `
      .navigation-tabs-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        background: var(--surface-primary);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        overflow: hidden;
      }
      
      .tabs-header {
        flex-shrink: 0;
        background: var(--surface-secondary);
        border-bottom: 0.125rem solid var(--border-subtle);
        padding: var(--spacing-md) var(--spacing-lg);
      }
      
      .tabs-list {
        display: flex;
        gap: var(--spacing-sm);
        align-items: center;
        overflow-x: auto;
        scroll-behavior: smooth;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      
      .tabs-list::-webkit-scrollbar {
        display: none;
      }
      
      .tab-button {
        flex: 1;
        min-width: clamp(8rem, 20vw, 12rem);
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--surface-tertiary);
        color: var(--text-secondary);
        border: 0.125rem solid transparent;
        border-radius: var(--radius-md);
        font-size: var(--font-sm);
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
        transition: all 0.2s ease;
        white-space: nowrap;
        text-decoration: none;
        user-select: none;
      }
      
      .tab-button:hover {
        background: var(--surface-hover);
        color: var(--text-primary);
        border-color: var(--border-medium);
        transform: translateY(-0.0625rem);
      }
      
      .tab-button.active {
        background: var(--color-primary);
        color: white;
        border-color: var(--color-primary);
        font-weight: 600;
        box-shadow: var(--shadow-sm);
      }
      
      .tab-button.active:hover {
        background: var(--color-primary-hover);
        transform: translateY(-0.0625rem);
      }
      
      .tab-icon {
        font-size: var(--font-md);
        line-height: 1;
        flex-shrink: 0;
      }
      
      .tab-title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
      }
      
      .tab-close {
        width: clamp(1rem, 2.5vw, 1.25rem);
        height: clamp(1rem, 2.5vw, 1.25rem);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: currentColor;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--font-xs);
        opacity: 0.7;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }
      
      .tab-close:hover {
        opacity: 1;
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }
      
      .tabs-content {
        flex: 1;
        min-height: 0;
        position: relative;
        overflow: hidden;
      }
      
      .tab-panel {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: var(--spacing-lg);
        background: var(--surface-primary);
        overflow-y: auto;
        opacity: 0;
        visibility: hidden;
        transform: translateX(0.625rem);
        transition: all 0.3s ease;
      }
      
      .tab-panel.active {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
        z-index: 1;
      }
      
      .tab-panel.entering {
        opacity: 0;
        transform: translateX(0.625rem);
      }
      
      .tab-panel.exiting {
        opacity: 0;
        transform: translateX(-0.625rem);
      }
      
      /* Variant: Pills */
      .navigation-tabs-container.variant-pills .tab-button {
        border-radius: var(--radius-lg);
        min-width: clamp(6rem, 15vw, 10rem);
      }
      
      .navigation-tabs-container.variant-pills .tabs-list {
        gap: var(--spacing-xs);
      }
      
      /* Variant: Underline */
      .navigation-tabs-container.variant-underline .tabs-header {
        border-bottom: 0.125rem solid var(--border-subtle);
        background: transparent;
      }
      
      .navigation-tabs-container.variant-underline .tab-button {
        background: transparent;
        border-radius: 0;
        border-bottom: 0.1875rem solid transparent;
        padding-bottom: calc(var(--spacing-sm) - 0.1875rem);
      }
      
      .navigation-tabs-container.variant-underline .tab-button:hover {
        background: rgba(59, 130, 246, 0.05);
        border-bottom-color: var(--color-primary);
      }
      
      .navigation-tabs-container.variant-underline .tab-button.active {
        background: rgba(59, 130, 246, 0.1);
        border-bottom-color: var(--color-primary);
        color: var(--color-primary);
      }
      
      /* Responsive Behavior */
      @media (max-width: 48rem) {
        .tab-button {
          min-width: clamp(6rem, 25vw, 8rem);
          padding: var(--spacing-xs) var(--spacing-sm);
          font-size: var(--font-xs);
        }
        
        .tab-icon {
          font-size: var(--font-sm);
        }
        
        .tabs-header {
          padding: var(--spacing-sm) var(--spacing-md);
        }
        
        .tab-panel {
          padding: var(--spacing-md);
        }
      }
      
      /* Loading State */
      .tab-panel-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--text-secondary);
      }
      
      .tab-panel-loading .loading-spinner {
        width: clamp(2rem, 5vw, 3rem);
        height: clamp(2rem, 5vw, 3rem);
        border: 0.25rem solid var(--border-subtle);
        border-top: 0.25rem solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: var(--spacing-md);
      }
      
      /* Error State */
      .tab-panel-error {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--color-error);
        text-align: center;
        padding: var(--spacing-xl);
      }
      
      .tab-panel-error .error-icon {
        font-size: var(--font-xxl);
        margin-bottom: var(--spacing-md);
      }
      
      .tab-panel-error .error-title {
        font-size: var(--font-lg);
        font-weight: 600;
        margin-bottom: var(--spacing-sm);
      }
      
      .tab-panel-error .error-message {
        font-size: var(--font-md);
        color: var(--text-secondary);
        max-width: 30rem;
        line-height: 1.6;
      }
    `;
  }
  
  injectCSS() {
    if (this.cssInjected) return;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = this.generateCSS();
    document.head.appendChild(styleElement);
    this.cssInjected = true;
  }
  
  render(modelData) {
    this.injectCSS();
    
    this.container.innerHTML = '';
    this.container.className = `navigation-tabs-container variant-${modelData.variant}`;
    
    // Create header with tabs
    const header = this.createTabsHeader(modelData);
    this.container.appendChild(header);
    
    // Create content area
    const content = this.createTabsContent(modelData);
    this.container.appendChild(content);
    
    // Store element references
    this.elements.set('header', header);
    this.elements.set('content', content);
    this.elements.set('tabsList', header.querySelector('.tabs-list'));
    
    return this.container;
  }
  
  createTabsHeader(modelData) {
    const header = document.createElement('div');
    header.className = 'tabs-header';
    
    const tabsList = document.createElement('div');
    tabsList.className = 'tabs-list';
    tabsList.setAttribute('role', 'tablist');
    
    modelData.tabs.forEach(tab => {
      const tabButton = this.createTabButton(tab, modelData);
      tabsList.appendChild(tabButton);
    });
    
    header.appendChild(tabsList);
    return header;
  }
  
  createTabButton(tab, modelData) {
    const button = document.createElement('button');
    button.className = `tab-button${tab.id === modelData.activeTab ? ' active' : ''}`;
    button.setAttribute('role', 'tab');
    button.setAttribute('aria-controls', `panel-${tab.id}`);
    button.setAttribute('aria-selected', tab.id === modelData.activeTab ? 'true' : 'false');
    button.dataset.tabId = tab.id;
    
    // Tab icon
    if (tab.icon && modelData.showIcons) {
      const icon = document.createElement('span');
      icon.className = 'tab-icon';
      icon.textContent = tab.icon;
      button.appendChild(icon);
    }
    
    // Tab title
    const title = document.createElement('span');
    title.className = 'tab-title';
    title.textContent = tab.title;
    button.appendChild(title);
    
    // Close button (if tabs are closable)
    if (modelData.closableTabs && tab.closable !== false) {
      const closeButton = document.createElement('button');
      closeButton.className = 'tab-close';
      closeButton.innerHTML = '√ó';
      closeButton.setAttribute('aria-label', `Close ${tab.title}`);
      closeButton.onclick = (e) => {
        e.stopPropagation();
        this.handleTabClose(tab.id);
      };
      button.appendChild(closeButton);
    }
    
    return button;
  }
  
  createTabsContent(modelData) {
    const content = document.createElement('div');
    content.className = 'tabs-content';
    
    modelData.tabs.forEach(tab => {
      const panel = this.createTabPanel(tab, modelData);
      content.appendChild(panel);
    });
    
    return content;
  }
  
  createTabPanel(tab, modelData) {
    const panel = document.createElement('div');
    panel.className = `tab-panel${tab.id === modelData.activeTab ? ' active' : ''}`;
    panel.setAttribute('role', 'tabpanel');
    panel.setAttribute('aria-labelledby', `tab-${tab.id}`);
    panel.id = `panel-${tab.id}`;
    panel.dataset.tabId = tab.id;
    
    // Initially show loading state
    this.showPanelLoading(panel, tab);
    
    return panel;
  }
  
  showPanelLoading(panel, tab) {
    panel.innerHTML = `
      <div class="tab-panel-loading">
        <div class="loading-spinner"></div>
        Loading ${tab.title}...
      </div>
    `;
  }
  
  showPanelError(panel, tab, error) {
    panel.innerHTML = `
      <div class="tab-panel-error">
        <div class="error-icon">‚ö†Ô∏è</div>
        <div class="error-title">Failed to Load ${tab.title}</div>
        <div class="error-message">${error.message || 'An unexpected error occurred'}</div>
      </div>
    `;
  }
  
  showPanelContent(panel, contentElement) {
    panel.innerHTML = '';
    panel.appendChild(contentElement);
  }
  
  setActiveTab(tabId, previousTabId = null) {
    // Update tab buttons
    const buttons = this.elements.get('tabsList')?.querySelectorAll('.tab-button');
    buttons?.forEach(button => {
      const isActive = button.dataset.tabId === tabId;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-selected', isActive ? 'true' : 'false');
    });
    
    // Update panels with animation
    const panels = this.elements.get('content')?.querySelectorAll('.tab-panel');
    panels?.forEach(panel => {
      const isActive = panel.dataset.tabId === tabId;
      
      if (isActive) {
        panel.classList.add('entering');
        requestAnimationFrame(() => {
          panel.classList.remove('entering');
          panel.classList.add('active');
        });
      } else if (panel.classList.contains('active')) {
        panel.classList.add('exiting');
        setTimeout(() => {
          panel.classList.remove('active', 'exiting');
        }, 300);
      }
    });
  }
}

class NavigationTabsViewModel {
  constructor(model, view, umbilical) {
    this.model = model;
    this.view = view;
    this.umbilical = umbilical;
    this.eventListeners = [];
    this.panelComponents = new Map();
    this.loadingPromises = new Map();
  }
  
  initialize() {
    this.render();
    this.setupEventListeners();
    this.loadInitialPanel();
    
    if (this.umbilical.onMount) {
      this.umbilical.onMount(this.createPublicAPI());
    }
    
    return this.createPublicAPI();
  }
  
  render() {
    this.view.render(this.model.getState());
  }
  
  setupEventListeners() {
    const tabsList = this.view.elements.get('tabsList');
    
    if (tabsList) {
      const handleTabClick = (event) => {
        const tabButton = event.target.closest('.tab-button');
        if (tabButton) {
          const tabId = tabButton.dataset.tabId;
          this.switchToTab(tabId);
        }
      };
      
      tabsList.addEventListener('click', handleTabClick);
      this.eventListeners.push(() => tabsList.removeEventListener('click', handleTabClick));
    }
    
    // Keyboard navigation
    const handleKeyDown = (event) => {
      if (event.target.classList.contains('tab-button')) {
        this.handleKeyboardNavigation(event);
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    this.eventListeners.push(() => document.removeEventListener('keydown', handleKeyDown));
  }
  
  handleKeyboardNavigation(event) {
    const tabs = this.model.getState('tabs');
    const currentIndex = tabs.findIndex(tab => tab.id === this.model.getState('activeTab'));
    
    let newIndex = currentIndex;
    
    switch (event.key) {
      case 'ArrowLeft':
        newIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
        break;
      case 'ArrowRight':
        newIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
        break;
      case 'Home':
        newIndex = 0;
        break;
      case 'End':
        newIndex = tabs.length - 1;
        break;
      default:
        return;
    }
    
    event.preventDefault();
    this.switchToTab(tabs[newIndex].id);
    
    // Focus the new tab button
    const newButton = this.view.container.querySelector(`[data-tab-id="${tabs[newIndex].id}"]`);
    if (newButton) {
      newButton.focus();
    }
  }
  
  async switchToTab(tabId) {
    const currentTab = this.model.getState('activeTab');
    if (currentTab === tabId) return;
    
    const tab = this.model.getState('tabs').find(t => t.id === tabId);
    if (!tab) return;
    
    // Update model state
    const previousTab = currentTab;
    this.model.setActiveTab(tabId);
    
    // Update view
    this.view.setActiveTab(tabId, previousTab);
    
    // Load panel content if not already loaded
    await this.loadPanelContent(tabId);
    
    // Notify parent component
    if (this.umbilical.onTabChange) {
      this.umbilical.onTabChange(tabId, tab);
    }
  }
  
  async loadInitialPanel() {
    const activeTabId = this.model.getState('activeTab');
    if (activeTabId) {
      await this.loadPanelContent(activeTabId);
    }
  }
  
  async loadPanelContent(tabId) {
    // Prevent duplicate loading
    if (this.loadingPromises.has(tabId)) {
      return this.loadingPromises.get(tabId);
    }
    
    const tab = this.model.getState('tabs').find(t => t.id === tabId);
    if (!tab) return;
    
    // If content is already loaded, don't reload
    if (this.panelComponents.has(tabId)) return;
    
    const panel = this.view.container.querySelector(`#panel-${tabId}`);
    if (!panel) return;
    
    // Create loading promise
    const loadingPromise = this.loadTabComponent(tab, panel);
    this.loadingPromises.set(tabId, loadingPromise);
    
    try {
      await loadingPromise;
    } catch (error) {
      console.error(`Failed to load tab ${tabId}:`, error);
      this.view.showPanelError(panel, tab, error);
    } finally {
      this.loadingPromises.delete(tabId);
    }
  }
  
  async loadTabComponent(tab, panel) {
    // Dynamic import based on tab configuration
    const componentName = tab.component;
    if (!componentName) return;
    
    try {
      // Import the component
      const module = await import(`./panels/${componentName}.js`);
      const ComponentClass = module[componentName] || module.default;
      
      if (!ComponentClass) {
        throw new Error(`Component ${componentName} not found in module`);
      }
      
      // Create container for the component
      const componentContainer = document.createElement('div');
      componentContainer.className = 'panel-component-container';
      
      // Create component instance
      const componentInstance = ComponentClass.create({
        dom: componentContainer,
        tabId: tab.id,
        onMount: () => console.log(`${componentName} mounted in tab ${tab.id}`),
        onError: (error) => {
          console.error(`${componentName} error:`, error);
          this.view.showPanelError(panel, tab, error);
        }
      });
      
      // Store component reference
      this.panelComponents.set(tab.id, componentInstance);
      
      // Show content
      this.view.showPanelContent(panel, componentContainer);
      
    } catch (error) {
      throw new Error(`Failed to load component ${componentName}: ${error.message}`);
    }
  }
  
  createPublicAPI() {
    return {
      // Navigation
      switchToTab: (tabId) => this.switchToTab(tabId),
      getActiveTab: () => this.model.getState('activeTab'),
      getTabs: () => this.model.getState('tabs'),
      
      // Tab management
      addTab: (tab) => this.addTab(tab),
      removeTab: (tabId) => this.removeTab(tabId),
      updateTab: (tabId, updates) => this.updateTab(tabId, updates),
      
      // Component access
      getTabComponent: (tabId) => this.panelComponents.get(tabId),
      
      // State
      getState: (path) => this.model.getState(path),
      
      // Cleanup
      destroy: () => this.destroy()
    };
  }
  
  addTab(tab) {
    const tabs = [...this.model.getState('tabs'), tab];
    this.model.updateState('tabs', tabs);
    this.render();
  }
  
  removeTab(tabId) {
    // Destroy component if exists
    const component = this.panelComponents.get(tabId);
    if (component && component.destroy) {
      component.destroy();
    }
    this.panelComponents.delete(tabId);
    
    // Remove from tabs array
    const tabs = this.model.getState('tabs').filter(tab => tab.id !== tabId);
    this.model.updateState('tabs', tabs);
    
    // Switch to another tab if this was active
    const activeTab = this.model.getState('activeTab');
    if (activeTab === tabId && tabs.length > 0) {
      this.switchToTab(tabs[0].id);
    }
    
    this.render();
  }
  
  updateTab(tabId, updates) {
    const tabs = this.model.getState('tabs').map(tab =>
      tab.id === tabId ? { ...tab, ...updates } : tab
    );
    this.model.updateState('tabs', tabs);
    this.render();
  }
  
  destroy() {
    // Clean up event listeners
    this.eventListeners.forEach(cleanup => cleanup());
    
    // Destroy all panel components
    this.panelComponents.forEach(component => {
      if (component.destroy) {
        component.destroy();
      }
    });
    this.panelComponents.clear();
    
    // Clear DOM
    this.view.container.innerHTML = '';
    
    if (this.umbilical.onDestroy) {
      this.umbilical.onDestroy();
    }
  }
}

export const NavigationTabs = {
  create(umbilical) {
    // Umbilical Protocol implementation
    if (umbilical.describe) {
      const requirements = UmbilicalUtils.createRequirements();
      requirements.add('dom', 'HTMLElement', 'Container element');
      requirements.add('tabs', 'array', 'Array of tab objects');
      requirements.add('activeTab', 'string', 'Initial active tab ID (optional)', false);
      requirements.add('variant', 'string', 'Tab variant: default|pills|underline (optional)', false);
      requirements.add('showIcons', 'boolean', 'Show tab icons (optional)', false);
      requirements.add('closableTabs', 'boolean', 'Enable tab closing (optional)', false);
      requirements.add('onTabChange', 'function', 'Tab change callback (optional)', false);
      requirements.add('onMount', 'function', 'Mount callback (optional)', false);
      umbilical.describe(requirements);
      return;
    }
    
    if (umbilical.validate) {
      return umbilical.validate({
        hasDomElement: umbilical.dom && umbilical.dom.nodeType === Node.ELEMENT_NODE,
        hasValidTabs: Array.isArray(umbilical.tabs) && umbilical.tabs.length > 0
      });
    }
    
    UmbilicalUtils.validateCapabilities(umbilical, ['dom', 'tabs'], 'NavigationTabs');
    
    const model = new NavigationTabsModel(umbilical);
    const view = new NavigationTabsView(umbilical.dom);
    const viewModel = new NavigationTabsViewModel(model, view, umbilical);
    
    return viewModel.initialize();
  }
};
```

## Implementation Timeline & Next Steps

### Phase 1: Foundation (Complete with above)
- ‚úÖ ToolRegistryBrowser root component with MVVM structure
- ‚úÖ ApplicationHeader component with responsive design
- ‚úÖ NavigationTabs component with dynamic panel loading

### Phase 2: Panel Components (Next Steps)
- **ToolSearchPanel** - Advanced search interface with filtering
- **ModuleBrowserPanel** - Hierarchical module explorer
- **ToolDetailsPanel** - Comprehensive tool information display
- **AdministrationPanel** - System management interface

### Phase 3: Data Integration
- WebSocket connection management
- Real-time data synchronization
- State persistence and restoration
- Error handling and retry logic

### Phase 4: Polish & Optimization
- Performance optimization
- Accessibility compliance (WCAG 2.1 AA)
- Cross-browser testing
- Mobile responsiveness verification

## Key Success Criteria

### ‚úÖ Architecture Compliance
- Zero hardcoded HTML in main application
- All styling through CSS classes with responsive units
- Strict MVVM separation in all components
- Umbilical Protocol implementation for all components

### ‚úÖ Responsive Design
- Fluid scaling from 320px to 4K+ displays
- No media queries needed (pure responsive units)
- Typography scaling with clamp() functions
- Component-level responsive behavior

### ‚úÖ Code Quality
- TypeScript-ready ES6 modules
- Comprehensive error handling
- Memory leak prevention
- Clean separation of concerns

This design document provides the complete blueprint for building a professional, maintainable, and fully responsive Tool Registry Browser using proper MVVM architecture and modern web development practices.