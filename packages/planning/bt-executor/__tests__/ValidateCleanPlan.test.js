/**
 * Just validate that the clean prompt generates a valid plan
 */

import { BTValidator } from '@legion/bt-validator';

describe('Validate Clean Plan', () => {
  test('should validate the plan from clean prompt', async () => {
    // This is the exact plan generated by our clean prompt
    const plan = {
      "type": "sequence",
      "id": "root", 
      "description": "Create and run Hello World program",
      "children": [
        {
          "type": "action",
          "id": "write-hello-world",
          "tool": "file_writer",
          "description": "Create hello world JavaScript file",
          "inputs": {
            "filePath": "hello.js",
            "content": "console.log('Hello World!');"
          },
          "outputs": {
            "filepath": "js_file_path"
          }
        },
        {
          "type": "action", 
          "id": "execute-hello-world",
          "tool": "run_node",
          "description": "Execute the hello world script",
          "inputs": {
            "projectPath": ".",
            "command": "node hello.js"
          }
        }
      ]
    };

    // Simple tool definitions matching what we used
    const tools = [
      {
        name: 'file_writer',
        description: 'Write content to a file',
        inputSchema: {
          type: 'object',
          properties: {
            filePath: { type: 'string', description: 'Path where file should be written' },
            content: { type: 'string', description: 'Content to write' }
          },
          required: ['filePath', 'content']
        }
      },
      {
        name: 'run_node',
        description: 'Execute JavaScript file using Node.js',
        inputSchema: {
          type: 'object',
          properties: {
            projectPath: { type: 'string', description: 'Project directory path' },
            command: { type: 'string', description: 'Command to execute' }
          },
          required: ['projectPath', 'command']
        }
      }
    ];

    const validator = new BTValidator({
      strictMode: true,
      validateTools: true,
      applyDefaults: true
    });

    console.log('\n=== Validating Generated Plan ===\n');
    console.log('Plan:', JSON.stringify(plan, null, 2));

    const validation = await validator.validate(plan, tools);
    
    console.log('\n=== Validation Result ===');
    console.log('Valid:', validation.valid);
    
    if (validation.errors && validation.errors.length > 0) {
      console.log('\nErrors:');
      validation.errors.forEach(err => {
        console.log(`  - ${err.type}: ${err.message}`);
        if (err.details) {
          console.log(`    Details:`, err.details);
        }
      });
    }
    
    if (validation.warnings && validation.warnings.length > 0) {
      console.log('\nWarnings:');
      validation.warnings.forEach(warn => {
        console.log(`  - ${warn.type}: ${warn.message}`);
      });
    }

    expect(validation.valid).toBe(true);
    
    // Test enrichment if method exists
    console.log('\n=== Testing Plan Enrichment (if available) ===');
    if (typeof validator.enrichPlan === 'function') {
      const enriched = await validator.enrichPlan(plan, tools);
      
      console.log('Enrichment success:', enriched.success);
      if (!enriched.success) {
        console.log('Enrichment error:', enriched.error);
      } else {
        console.log('Enriched plan has tool IDs');
      }
      
      expect(enriched.success).toBe(true);
    } else {
      console.log('enrichPlan method not available on validator');
    }
    
    console.log('\nâœ… Plan is valid and can be enriched');
  });
});