/**
 * Test suite specifically for the Hello World behavior tree from formal planning
 * Ensures the executor can handle the actual tree structure generated by the planner
 */

import { DebugBehaviorTreeExecutor } from '../src/DebugBehaviorTreeExecutor.js';
import { NodeStatus } from '@legion/actor-bt';

describe('Hello World Behavior Tree Execution', () => {
  let executor;
  let mockToolRegistry;
  let toolMocks;
  
  // The actual behavior tree from the formal planning output
  const helloWorldTree = {
    "id": "hello-world-js",
    "description": "Create and run a JavaScript Hello World program",
    "type": "sequence",
    "children": [
      {
        "type": "retry",
        "id": "retry-create-dir",
        "maxAttempts": 3,
        "description": "Create project directory with retry",
        "child": {
          "type": "sequence",
          "id": "create-dir-sequence",
          "description": "Create directory and verify",
          "children": [
            {
              "type": "action",
              "id": "create-project-dir",
              "tool": "directory_create",
              "description": "Create project directory",
              "outputVariable": "dirResult",
              "params": {
                "path": "./hello-world"
              }
            },
            {
              "type": "condition",
              "id": "check-dir-created",
              "check": "context.artifacts['dirResult'].success === true",
              "description": "Verify directory was created"
            }
          ]
        }
      },
      {
        "type": "retry",
        "id": "retry-write-file",
        "maxAttempts": 3,
        "description": "Write JavaScript file with retry",
        "child": {
          "type": "sequence",
          "id": "write-file-sequence",
          "description": "Write file and verify",
          "children": [
            {
              "type": "action",
              "id": "write-js-file",
              "tool": "file_write",
              "description": "Write Hello World JavaScript file",
              "outputVariable": "fileResult",
              "params": {
                "filepath": "./hello-world/index.js",
                "content": "console.log('Hello, World!');"
              }
            },
            {
              "type": "condition",
              "id": "check-file-written",
              "check": "context.artifacts['fileResult'].success === true",
              "description": "Verify file was written successfully"
            }
          ]
        }
      },
      {
        "type": "retry",
        "id": "retry-run-program",
        "maxAttempts": 3,
        "description": "Execute the JavaScript program with retry",
        "child": {
          "type": "sequence",
          "id": "run-program-sequence",
          "description": "Run program and verify output",
          "children": [
            {
              "type": "action",
              "id": "execute-program",
              "tool": "run_node",
              "description": "Execute the JavaScript program",
              "outputVariable": "execResult",
              "params": {
                "filepath": "./hello-world/index.js"
              }
            },
            {
              "type": "condition",
              "id": "check-execution",
              "check": "context.artifacts['execResult'].success === true",
              "description": "Verify program executed successfully"
            }
          ]
        }
      }
    ]
  };
  
  beforeEach(() => {
    // Create tool mocks
    toolMocks = {
      directory_create: {
        execute: jest.fn().mockResolvedValue({
          success: true,
          data: { path: './hello-world', created: true }
        })
      },
      file_write: {
        execute: jest.fn().mockResolvedValue({
          success: true,
          data: { filepath: './hello-world/index.js', written: true }
        })
      },
      run_node: {
        execute: jest.fn().mockResolvedValue({
          success: true,
          data: { 
            output: 'Hello, World!',
            exitCode: 0
          }
        })
      }
    };
    
    // Create mock tool registry
    mockToolRegistry = {
      getTool: jest.fn((toolName) => {
        return Promise.resolve(toolMocks[toolName] || null);
      })
    };
    
    executor = new DebugBehaviorTreeExecutor(mockToolRegistry);
  });
  
  describe('Tree Structure Validation', () => {
    test('should successfully initialize the Hello World tree', async () => {
      const result = await executor.initializeTree(helloWorldTree);
      
      expect(result.success).toBe(true);
      expect(result.treeId).toBe('hello-world-js');
      expect(result.nodeCount).toBe(13); // Count all nodes in the tree
    });
    
    test('should correctly identify all nodes', async () => {
      await executor.initializeTree(helloWorldTree);
      const state = executor.getExecutionState();
      
      // Check that all node IDs are tracked
      const expectedNodeIds = [
        'hello-world-js',
        'retry-create-dir',
        'create-dir-sequence',
        'create-project-dir',
        'check-dir-created',
        'retry-write-file',
        'write-file-sequence',
        'write-js-file',
        'check-file-written',
        'retry-run-program',
        'run-program-sequence',
        'execute-program',
        'check-execution'
      ];
      
      expectedNodeIds.forEach(nodeId => {
        expect(state.nodeStates).toHaveProperty(nodeId);
        expect(state.nodeStates[nodeId]).toBe('pending');
      });
    });
  });
  
  describe('Step-through Execution', () => {
    test('should execute Hello World tree step by step', async () => {
      await executor.initializeTree(helloWorldTree);
      
      const steps = [];
      const stepListener = jest.fn((data) => steps.push(data));
      executor.on('node:step', stepListener);
      
      // Execute until complete
      let result;
      let stepCount = 0;
      const maxSteps = 20; // Safety limit
      
      do {
        result = await executor.stepNext();
        stepCount++;
      } while (!result.complete && stepCount < maxSteps);
      
      expect(result.complete).toBe(true);
      expect(result.success).toBe(true);
      
      // Verify all tools were called
      expect(toolMocks.directory_create.execute).toHaveBeenCalledWith({
        path: './hello-world'
      });
      expect(toolMocks.file_write.execute).toHaveBeenCalledWith({
        filepath: './hello-world/index.js',
        content: "console.log('Hello, World!');"
      });
      expect(toolMocks.run_node.execute).toHaveBeenCalledWith({
        filepath: './hello-world/index.js'
      });
    });
    
    test('should handle node-by-node debugging', async () => {
      await executor.initializeTree(helloWorldTree);
      
      // Set breakpoint on file write
      executor.addBreakpoint('write-js-file');
      
      const breakpointHit = new Promise((resolve) => {
        executor.on('breakpoint:hit', (data) => {
          resolve(data);
        });
      });
      
      // Start execution in run mode
      executor.setMode('run');
      const runPromise = executor.runToCompletion();
      
      // Wait for breakpoint
      const bpData = await breakpointHit;
      expect(bpData.nodeId).toBe('write-js-file');
      
      // Check state at breakpoint
      const state = executor.getExecutionState();
      expect(state.nodeStates['create-project-dir']).toBe('success');
      expect(state.nodeStates['write-js-file']).toBe('running');
      
      // Resume execution
      executor.resume();
      
      const result = await runPromise;
      expect(result.complete).toBe(true);
      expect(result.success).toBe(true);
    });
  });
  
  describe('Retry Logic', () => {
    test('should retry on failure', async () => {
      let createDirAttempts = 0;
      
      // Make directory creation fail first time
      toolMocks.directory_create.execute = jest.fn().mockImplementation(() => {
        createDirAttempts++;
        if (createDirAttempts === 1) {
          return Promise.resolve({
            success: false,
            error: 'Directory already exists'
          });
        }
        return Promise.resolve({
          success: true,
          data: { path: './hello-world', created: true }
        });
      });
      
      await executor.initializeTree(helloWorldTree);
      executor.setMode('run');
      
      const result = await executor.runToCompletion();
      
      expect(result.complete).toBe(true);
      expect(result.success).toBe(true);
      expect(createDirAttempts).toBe(2); // Failed once, succeeded on retry
    });
    
    test('should fail after max retry attempts', async () => {
      // Make directory creation always fail
      toolMocks.directory_create.execute = jest.fn().mockResolvedValue({
        success: false,
        error: 'Permission denied'
      });
      
      await executor.initializeTree(helloWorldTree);
      executor.setMode('run');
      
      const result = await executor.runToCompletion();
      
      expect(result.complete).toBe(true);
      expect(result.success).toBe(false);
      expect(toolMocks.directory_create.execute).toHaveBeenCalledTimes(3); // maxAttempts
    });
  });
  
  describe('Condition Checks', () => {
    test('should verify conditions correctly', async () => {
      await executor.initializeTree(helloWorldTree);
      
      // Execute through directory creation
      let result;
      do {
        result = await executor.stepNext();
        const state = executor.getExecutionState();
        
        // If we just executed create-project-dir, check that the condition passes
        if (state.currentNode === 'check-dir-created') {
          // The condition should evaluate based on context.artifacts
          expect(state.context.artifacts).toHaveProperty('dirResult');
          expect(state.context.artifacts.dirResult.success).toBe(true);
        }
      } while (!result.complete);
      
      expect(result.success).toBe(true);
    });
    
    test('should fail condition when tool fails', async () => {
      // Make file write fail
      toolMocks.file_write.execute = jest.fn().mockResolvedValue({
        success: false,
        error: 'Disk full'
      });
      
      await executor.initializeTree(helloWorldTree);
      executor.setMode('run');
      
      const result = await executor.runToCompletion();
      
      expect(result.complete).toBe(true);
      expect(result.success).toBe(false);
      
      // File write should have been attempted 3 times due to retry
      expect(toolMocks.file_write.execute).toHaveBeenCalledTimes(3);
    });
  });
  
  describe('Execution History', () => {
    test('should maintain complete execution history', async () => {
      await executor.initializeTree(helloWorldTree);
      executor.setMode('run');
      
      const result = await executor.runToCompletion();
      
      expect(result.complete).toBe(true);
      expect(result.success).toBe(true);
      
      const state = executor.getExecutionState();
      
      // History should contain all executed nodes
      const executedNodeIds = state.history.map(h => h.nodeId);
      
      // Should have executed key nodes
      expect(executedNodeIds).toContain('create-project-dir');
      expect(executedNodeIds).toContain('write-js-file');
      expect(executedNodeIds).toContain('execute-program');
      
      // All executed nodes should have success status
      state.history.forEach(entry => {
        if (entry.nodeType === 'action' || entry.nodeType === 'condition') {
          expect(entry.status).toBe(NodeStatus.SUCCESS);
        }
      });
    });
  });
  
  describe('State Inspection', () => {
    test('should provide detailed state at any point', async () => {
      await executor.initializeTree(helloWorldTree);
      
      // Step to middle of execution
      for (let i = 0; i < 5; i++) {
        await executor.stepNext();
      }
      
      const state = executor.getExecutionState();
      
      expect(state).toMatchObject({
        mode: 'step',
        isPaused: false,
        currentNode: expect.any(String),
        nodeStates: expect.any(Object),
        breakpoints: expect.any(Array),
        history: expect.any(Array),
        context: expect.objectContaining({
          artifacts: expect.any(Object)
        })
      });
      
      // Some nodes should be complete, others pending
      const nodeStateValues = Object.values(state.nodeStates);
      expect(nodeStateValues).toContain('success');
      expect(nodeStateValues).toContain('pending');
    });
    
    test('should track artifacts through execution', async () => {
      await executor.initializeTree(helloWorldTree);
      executor.setMode('run');
      
      await executor.runToCompletion();
      
      const state = executor.getExecutionState();
      
      // Should have all three artifacts
      expect(state.context.artifacts).toHaveProperty('dirResult');
      expect(state.context.artifacts).toHaveProperty('fileResult');
      expect(state.context.artifacts).toHaveProperty('execResult');
      
      // All should be successful
      expect(state.context.artifacts.dirResult.success).toBe(true);
      expect(state.context.artifacts.fileResult.success).toBe(true);
      expect(state.context.artifacts.execResult.success).toBe(true);
    });
  });
  
  describe('Reset and Re-execution', () => {
    test('should allow reset and re-execution', async () => {
      await executor.initializeTree(helloWorldTree);
      
      // First execution
      executor.setMode('run');
      let result = await executor.runToCompletion();
      expect(result.success).toBe(true);
      
      // Reset
      executor.reset();
      
      const state = executor.getExecutionState();
      expect(state.history).toHaveLength(0);
      expect(state.currentNode).toBeNull();
      
      // All nodes should be pending again
      Object.values(state.nodeStates).forEach(nodeState => {
        expect(nodeState).toBe('pending');
      });
      
      // Second execution
      result = await executor.runToCompletion();
      expect(result.success).toBe(true);
      
      // Tools should have been called twice total
      expect(toolMocks.directory_create.execute).toHaveBeenCalledTimes(2);
      expect(toolMocks.file_write.execute).toHaveBeenCalledTimes(2);
      expect(toolMocks.run_node.execute).toHaveBeenCalledTimes(2);
    });
  });
});