/**
 * Live Plan Execution Test
 * 
 * This test demonstrates executing a plan generated by the profile planner
 * using the PlanExecutorModule.
 */

import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { ModuleLoader, ResourceManager, ModuleFactory } from '@legion/module-loader';
import { PlanExecutorModule } from '../../src/PlanExecutorModule.js';
import { FileModule } from '../../../general-tools/src/file/FileModule.js';
import NodeRunner from '../../../node-runner/src/NodeRunner.js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('PlanExecutor Live Execution', () => {
  let resourceManager;
  let moduleFactory;
  let planExecutorModule;
  let testDir;
  let plan;
  
  beforeAll(async () => {
    // Setup test directory
    testDir = path.join(__dirname, '..', 'tmp', 'plan-execution-test');
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // Directory might not exist
    }
    await fs.mkdir(testDir, { recursive: true });
    console.log(`\nTest directory: ${testDir}`);
    
    // Initialize ResourceManager
    resourceManager = new ResourceManager();
    await resourceManager.initialize();
    
    // Create a custom module registry since ModuleFactory doesn't have registerModule
    const moduleRegistry = new Map();
    
    // Register modules
    moduleRegistry.set('file', FileModule);
    
    // Create a module wrapper for NodeRunner
    class NodeRunnerModule {
      constructor() {
        this.nodeRunner = new NodeRunner({ logManager: null });
      }
      
      async executeCommand(command, options = {}) {
        return this.nodeRunner.executeCommand(command, options);
      }
      
      async cleanup() {
        return this.nodeRunner.cleanup();
      }
      
      getTools() {
        // NodeRunner doesn't have tools in the Legion sense
        return [];
      }
    }
    moduleRegistry.set('node-runner', NodeRunnerModule);
    
    // Create ModuleFactory with custom getModule method
    moduleFactory = {
      getModule: (moduleName) => moduleRegistry.get(moduleName),
      createModule: (ModuleClass) => {
        return new ModuleClass();
      }
    };
    
    // Create PlanExecutorModule
    planExecutorModule = new PlanExecutorModule({
      resourceManager,
      moduleFactory
    });
    
    // Override the planToolRegistry to use only file operations for this test
    // Since we're testing with a mock file plan that doesn't need command execution
    planExecutorModule.planToolRegistry = {
      async loadModulesForPlan(plan) {
        // Mock - don't actually load modules
      },
      getTool(toolName) {
        // Return mock file tools
        const mockFileTools = {
          file_write: {
            execute: async (params) => ({
              success: true,
              path: params.filepath,
              content: params.content
            })
          },
          file_read: {
            execute: async (params) => ({
              success: true,
              content: 'mock file content',
              path: params.filepath
            })
          }
        };
        
        const tool = mockFileTools[toolName];
        if (!tool) {
          throw new Error(`Tool not found: ${toolName}`);
        }
        return tool;
      }
    };
    
    // Load the plan
    const planPath = path.join(__dirname, '..', 'fixtures', 'math-utility-plan.json');
    const planContent = await fs.readFile(planPath, 'utf8');
    plan = JSON.parse(planContent);
    
    console.log(`\nLoaded plan: ${plan.name}`);
    console.log(`Steps: ${plan.steps.length}`);
    console.log(`Total actions: ${plan.steps.reduce((sum, step) => sum + step.actions.length, 0)}`);
  });
  
  afterAll(async () => {
    // Cleanup
    const nodeRunnerModule = moduleFactory.getModule('node-runner');
    if (nodeRunnerModule && nodeRunnerModule.cleanup) {
      await nodeRunnerModule.cleanup();
    }
  });
  
  describe('Plan Execution via PlanExecutor', () => {
    test('should execute the math utility plan using plan_execute tool', async () => {
      // Change to test directory for execution
      const originalCwd = process.cwd();
      process.chdir(testDir);
      console.log(`Working directory: ${process.cwd()}`);
      
      try {
        // Get the plan_execute tool
        const tools = planExecutorModule.getTools();
        const planExecuteTool = tools.find(tool => tool.name === 'plan_execute');
        expect(planExecuteTool).toBeDefined();
        
        console.log(`\nðŸš€ Executing plan using PlanExecutor...`);
        
        // Create the tool invocation
        const toolCall = {
          function: {
            name: 'plan_execute',
            arguments: JSON.stringify({
              plan: plan,
              options: {
                parallel: false,
                stopOnError: true
              }
            })
          }
        };
        
        // Execute the plan
        const result = await planExecuteTool.invoke(toolCall);
        
        console.log(`\nðŸ“‹ Execution Result:`);
        console.log(`Success: ${result.success}`);
        
        if (result.success) {
          console.log(`Execution ID: ${result.data.executionId}`);
          console.log(`Status: ${result.data.status}`);
          console.log(`Steps Completed: ${result.data.completedSteps}/${result.data.totalSteps}`);
          
          // Check execution details
          if (result.data.results) {
            console.log(`\nðŸ“„ Step Results:`);
            for (const [stepId, stepResult] of Object.entries(result.data.results)) {
              console.log(`  ${stepId}: ${stepResult.status}`);
              if (stepResult.error) {
                console.log(`    Error: ${stepResult.error}`);
              }
            }
          }
        } else {
          console.log(`Error: ${result.error}`);
        }
        
        // Verify the plan executed successfully
        expect(result.success).toBe(true);
        expect(result.data.status).toBe('completed');
        expect(result.data.completedSteps).toBe(plan.steps.length);
        
        // Verify files were created
        const expectedFiles = [
          './src/mathUtils.js',
          './test/mathUtils.test.js',
          './package.json'
        ];
        
        console.log(`\nðŸ“ Verifying created files...`);
        for (const file of expectedFiles) {
          const exists = await fs.stat(file).then(() => true).catch(() => false);
          console.log(`  ${file}: ${exists ? 'âœ…' : 'âŒ'}`);
          expect(exists).toBe(true);
        }
        
        // Read and verify the math module
        const mathModuleContent = await fs.readFile('./src/mathUtils.js', 'utf8');
        expect(mathModuleContent).toContain('add:');
        expect(mathModuleContent).toContain('subtract:');
        
        // Run the test to verify it works
        console.log(`\nðŸ§ª Running the generated test...`);
        const nodeRunnerModule = moduleFactory.getModule('node-runner');
        const testResult = await nodeRunnerModule.executeCommand('node test/mathUtils.test.js');
        
        console.log(`Test output:`);
        console.log(testResult.stdout);
        
        expect(testResult.success).toBe(true);
        expect(testResult.stdout).toContain('Test PASSED');
        
      } finally {
        // Restore original working directory
        process.chdir(originalCwd);
      }
    }, 30000); // 30 second timeout
    
    test('should handle plan validation and provide useful feedback', async () => {
      // Test with an invalid plan (missing required fields)
      const invalidPlan = {
        name: "Invalid Plan",
        steps: []
      };
      
      const planExecuteTool = planExecutorModule.getTool('plan_execute');
      
      const toolCall = {
        function: {
          name: 'plan_execute',
          arguments: JSON.stringify({
            plan: invalidPlan
          })
        }
      };
      
      const result = await planExecuteTool.invoke(toolCall);
      
      // Should fail gracefully with validation error
      expect(result.success).toBe(false);
      expect(result.error).toContain('validation');
    });
  });
  
  describe('Plan Status and Debugging', () => {
    test('should provide plan status during execution', async () => {
      // This would test the plan_status tool
      const planStatusTool = planExecutorModule.getTool('plan_status');
      expect(planStatusTool).toBeDefined();
      
      // Would need to execute a plan first and then check status
      // This is a placeholder for the full implementation
    });
  });
});