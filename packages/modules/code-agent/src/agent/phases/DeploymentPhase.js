/**
 * DeploymentPhase - Handles application deployment
 * 
 * Responsible for deploying generated applications to various providers
 * using Conan-the-Deployer integration.
 */

class DeploymentPhase {
  constructor(codeAgent) {
    this.codeAgent = codeAgent;
    this.deploymentIntegration = null;
    this.deploymentConfig = null;
    this.deploymentResult = null;
  }

  /**
   * Initialize deployment phase with integration
   * @param {Object} deploymentIntegration - DeploymentIntegration instance
   */
  async initialize(deploymentIntegration) {
    this.deploymentIntegration = deploymentIntegration;
    await this.deploymentIntegration.initialize();
  }

  /**
   * Deploy the generated application
   * @param {Object} config - Deployment configuration
   * @returns {Promise<Object>} Deployment result
   */
  async deployApplication(config = {}) {
    this.codeAgent.emit('progress', {
      phase: 'deployment',
      step: 'starting',
      message: 'üöÄ Starting deployment process...'
    });

    try {
      // Merge with default config
      this.deploymentConfig = {
        provider: config.provider || this.codeAgent.config.deployment?.provider || 'local',
        name: config.name || this.codeAgent.projectPlan?.projectName || 'generated-app',
        projectPath: config.projectPath || this.codeAgent.config.workingDirectory,
        ...config
      };

      // Validate deployment configuration
      const validation = await this._validateDeploymentConfig();
      if (!validation.valid) {
        throw new Error(`Invalid deployment configuration: ${validation.errors.join(', ')}`);
      }

      // Prepare deployment based on project type
      await this._prepareDeployment();

      // Execute deployment
      this.codeAgent.emit('progress', {
        phase: 'deployment',
        step: 'deploying',
        message: `üì¶ Deploying to ${this.deploymentConfig.provider}...`
      });

      const deploymentResult = await this.deploymentIntegration.deploy({
        projectPath: this.deploymentConfig.projectPath,
        provider: this.deploymentConfig.provider,
        name: this.deploymentConfig.name,
        config: this._buildProviderConfig()
      });

      if (!deploymentResult.success) {
        throw new Error(deploymentResult.error || 'Deployment failed');
      }

      this.deploymentResult = deploymentResult;

      // Monitor initial deployment status
      if (this.deploymentConfig.monitor) {
        await this._monitorDeployment(deploymentResult.id);
      }

      this.codeAgent.emit('phase-complete', {
        phase: 'deployment',
        message: `Deployment completed successfully!`,
        result: deploymentResult
      });

      return {
        success: true,
        deploymentId: deploymentResult.id,
        provider: deploymentResult.provider,
        url: deploymentResult.url,
        status: deploymentResult.status,
        details: deploymentResult
      };

    } catch (error) {
      this.codeAgent.emit('error', {
        phase: 'deployment',
        message: `Deployment failed: ${error.message}`,
        error: error.message
      });

      return {
        success: false,
        error: error.message,
        provider: this.deploymentConfig.provider,
        attempted: true
      };
    }
  }

  /**
   * Validate deployment configuration
   * @private
   */
  async _validateDeploymentConfig() {
    const errors = [];

    // Check if deployment integration is initialized
    if (!this.deploymentIntegration) {
      errors.push('Deployment integration not initialized');
    }

    // Validate provider
    const supportedProviders = await this.deploymentIntegration?.getSupportedProviders() || [];
    if (!supportedProviders.includes(this.deploymentConfig.provider)) {
      errors.push(`Unsupported provider: ${this.deploymentConfig.provider}. Supported: ${supportedProviders.join(', ')}`);
    }

    // Validate project path exists
    if (!this.codeAgent.fileOps) {
      errors.push('File operations manager not available');
    } else {
      const pathExists = await this.codeAgent.fileOps.directoryExists(this.deploymentConfig.projectPath);
      if (!pathExists) {
        errors.push(`Project path does not exist: ${this.deploymentConfig.projectPath}`);
      }
    }

    // Check for required files based on provider
    if (this.deploymentConfig.provider === 'docker') {
      const dockerfilePath = `${this.deploymentConfig.projectPath}/Dockerfile`;
      const hasDockerfile = await this.codeAgent.fileOps.fileExists(dockerfilePath);
      if (!hasDockerfile && !this.deploymentConfig.autoGenerateDockerfile) {
        errors.push('Dockerfile not found. Set autoGenerateDockerfile: true to generate one.');
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Prepare deployment based on project requirements
   * @private
   */
  async _prepareDeployment() {
    this.codeAgent.emit('progress', {
      phase: 'deployment',
      step: 'preparing',
      message: 'üìã Preparing deployment configuration...'
    });

    // Generate package.json if missing
    if (!await this._hasPackageJson()) {
      await this._generatePackageJson();
    }

    // Generate Dockerfile for Docker deployments
    if (this.deploymentConfig.provider === 'docker' && this.deploymentConfig.autoGenerateDockerfile) {
      await this._generateDockerfile();
    }

    // Generate deployment-specific configurations
    if (this.deploymentConfig.provider === 'railway') {
      await this._generateRailwayConfig();
    }

    // Set up environment variables
    if (this.deploymentConfig.environment) {
      await this._prepareEnvironmentVariables();
    }
  }

  /**
   * Check if package.json exists
   * @private
   */
  async _hasPackageJson() {
    const packageJsonPath = `${this.deploymentConfig.projectPath}/package.json`;
    return await this.codeAgent.fileOps.fileExists(packageJsonPath);
  }

  /**
   * Generate package.json for deployment
   * @private
   */
  async _generatePackageJson() {
    this.codeAgent.emit('progress', {
      phase: 'deployment',
      step: 'package-json',
      message: 'üìÑ Generating package.json...'
    });

    const projectPlan = this.codeAgent.projectPlan;
    const packageJson = {
      name: this.deploymentConfig.name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
      version: "1.0.0",
      description: projectPlan?.description || "Generated application",
      main: this._findMainFile(),
      scripts: {
        start: this._determineStartScript(),
        test: "echo \"Error: no test specified\" && exit 1"
      },
      keywords: projectPlan?.keywords || [],
      author: "",
      license: "ISC",
      dependencies: this._extractDependencies()
    };

    const packageJsonPath = `${this.deploymentConfig.projectPath}/package.json`;
    await this.codeAgent.fileOps.writeFile(
      packageJsonPath,
      JSON.stringify(packageJson, null, 2)
    );

    this.codeAgent.emit('file-created', {
      phase: 'deployment',
      filename: 'package.json',
      path: packageJsonPath
    });
  }

  /**
   * Find the main entry file
   * @private
   */
  _findMainFile() {
    // Look for common entry points
    const possibleEntries = ['index.js', 'app.js', 'server.js', 'main.js'];
    const generatedFiles = Array.from(this.codeAgent.generatedFiles || []);
    
    for (const entry of possibleEntries) {
      if (generatedFiles.some(file => file.endsWith(entry))) {
        return entry;
      }
    }

    // Default to first JS file
    const jsFile = generatedFiles.find(file => file.endsWith('.js'));
    return jsFile ? jsFile.split('/').pop() : 'index.js';
  }

  /**
   * Determine the start script
   * @private
   */
  _determineStartScript() {
    const mainFile = this._findMainFile();
    const projectType = this.codeAgent.config.projectType;

    if (projectType === 'backend' || projectType === 'fullstack') {
      return `node ${mainFile}`;
    } else {
      // For frontend projects, might need a simple server
      return "python -m http.server 8000 || npx http-server -p 8000";
    }
  }

  /**
   * Extract dependencies from generated code
   * @private
   */
  _extractDependencies() {
    const dependencies = {};
    const projectType = this.codeAgent.config.projectType;

    // Add common dependencies based on project type
    if (projectType === 'backend' || projectType === 'fullstack') {
      // Check generated files for framework usage
      const generatedFiles = Array.from(this.codeAgent.generatedFiles || []);
      const hasExpress = generatedFiles.some(file => 
        file.includes('express') || file.includes('app.listen')
      );

      if (hasExpress) {
        dependencies.express = "^4.18.2";
      }
    }

    // Add any dependencies from deployment config
    if (this.deploymentConfig.dependencies) {
      Object.assign(dependencies, this.deploymentConfig.dependencies);
    }

    return dependencies;
  }

  /**
   * Generate Dockerfile for Docker deployments
   * @private
   */
  async _generateDockerfile() {
    this.codeAgent.emit('progress', {
      phase: 'deployment',
      step: 'dockerfile',
      message: 'üê≥ Generating Dockerfile...'
    });

    const projectType = this.codeAgent.config.projectType;
    let dockerfileContent = '';

    if (projectType === 'frontend') {
      dockerfileContent = this._generateFrontendDockerfile();
    } else {
      dockerfileContent = this._generateBackendDockerfile();
    }

    const dockerfilePath = `${this.deploymentConfig.projectPath}/Dockerfile`;
    await this.codeAgent.fileOps.writeFile(dockerfilePath, dockerfileContent);

    this.codeAgent.emit('file-created', {
      phase: 'deployment',
      filename: 'Dockerfile',
      path: dockerfilePath
    });
  }

  /**
   * Generate Dockerfile for frontend projects
   * @private
   */
  _generateFrontendDockerfile() {
    return `FROM nginx:alpine

# Copy static files
COPY . /usr/share/nginx/html

# Expose port
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
`;
  }

  /**
   * Generate Dockerfile for backend projects
   * @private
   */
  _generateBackendDockerfile() {
    const mainFile = this._findMainFile();
    return `FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install --production

# Copy application files
COPY . .

# Expose port
EXPOSE ${this.deploymentConfig.port || 3000}

# Start application
CMD ["node", "${mainFile}"]
`;
  }

  /**
   * Generate Railway-specific configuration
   * @private
   */
  async _generateRailwayConfig() {
    // Railway uses Nixpacks by default, but we can add railway.json if needed
    if (this.deploymentConfig.railwayConfig) {
      const railwayConfig = {
        build: {
          builder: "NIXPACKS"
        },
        deploy: {
          startCommand: this._determineStartScript()
        }
      };

      const configPath = `${this.deploymentConfig.projectPath}/railway.json`;
      await this.codeAgent.fileOps.writeFile(
        configPath,
        JSON.stringify(railwayConfig, null, 2)
      );
    }
  }

  /**
   * Prepare environment variables for deployment
   * @private
   */
  async _prepareEnvironmentVariables() {
    // Environment variables are passed to the deployment config
    // but we might want to create .env.example
    const envExample = Object.keys(this.deploymentConfig.environment)
      .map(key => `${key}=`)
      .join('\n');

    if (envExample) {
      const envPath = `${this.deploymentConfig.projectPath}/.env.example`;
      await this.codeAgent.fileOps.writeFile(envPath, envExample);
    }
  }

  /**
   * Build provider-specific configuration
   * @private
   */
  _buildProviderConfig() {
    const config = {
      env: this.deploymentConfig.environment || {},
      port: this.deploymentConfig.port || 3000,
      healthCheckPath: this.deploymentConfig.healthCheckPath || '/health'
    };

    // Add provider-specific configurations
    switch (this.deploymentConfig.provider) {
      case 'docker':
        config.dockerfile = this.deploymentConfig.dockerfile || './Dockerfile';
        config.buildArgs = this.deploymentConfig.buildArgs || {};
        config.network = this.deploymentConfig.network;
        break;
      
      case 'railway':
        // Railway requires source and repo/githubRepo fields
        config.source = this.deploymentConfig.source || 'github';
        config.repo = this.deploymentConfig.githubRepo || this.deploymentConfig.repo;
        config.branch = this.deploymentConfig.branch || 'main';
        config.projectId = this.deploymentConfig.railwayProjectId;
        config.environmentName = this.deploymentConfig.environmentName || 'production';
        config.region = this.deploymentConfig.region;
        config.environment = this.deploymentConfig.environment || {};
        config.generateDomain = this.deploymentConfig.generateDomain !== false; // Default to true
        
        // Pass through all deployment config to ensure Railway gets what it needs
        Object.assign(config, this.deploymentConfig);
        break;
      
      case 'local':
        config.startCommand = this.deploymentConfig.startCommand || this._determineStartScript();
        break;
    }

    return config;
  }

  /**
   * Monitor deployment status
   * @private
   */
  async _monitorDeployment(deploymentId) {
    this.codeAgent.emit('progress', {
      phase: 'deployment',
      step: 'monitoring',
      message: 'üìä Monitoring deployment status...'
    });

    try {
      const monitorResult = await this.deploymentIntegration.monitor({
        deploymentId: deploymentId,
        duration: 30000, // Monitor for 30 seconds
        interval: 5000   // Check every 5 seconds
      });

      if (monitorResult.health?.status === 'healthy') {
        this.codeAgent.emit('progress', {
          phase: 'deployment',
          step: 'healthy',
          message: '‚úÖ Deployment is healthy and running!'
        });
      }

      return monitorResult;
    } catch (error) {
      this.codeAgent.emit('warning', {
        phase: 'deployment',
        message: `Monitoring failed: ${error.message}`,
        error: error.message
      });
    }
  }

  /**
   * Monitor deployment status
   * @param {Object} options - Monitor options
   * @param {string} options.deploymentId - Deployment ID to monitor
   * @param {number} options.duration - How long to monitor (ms)
   * @param {number} options.interval - Check interval (ms)
   */
  async monitor(options = {}) {
    if (!this.deploymentIntegration) {
      throw new Error('Deployment integration not initialized');
    }

    const deploymentId = options.deploymentId || this.deploymentResult?.id;
    if (!deploymentId) {
      throw new Error('No deployment ID available to monitor');
    }

    return await this.deploymentIntegration.monitor({
      deploymentId: deploymentId,
      duration: options.duration || 30000,
      interval: options.interval || 5000
    });
  }

  /**
   * Get deployment logs
   * @param {string} deploymentId - Deployment ID
   * @param {Object} options - Log options
   */
  async getDeploymentLogs(deploymentId, options = {}) {
    if (!this.deploymentIntegration) {
      throw new Error('Deployment integration not initialized');
    }

    return await this.deploymentIntegration.getLogs({
      deploymentId: deploymentId || this.deploymentResult?.id,
      lines: options.lines || 100,
      follow: options.follow || false
    });
  }

  /**
   * Stop deployment
   * @param {string} deploymentId - Deployment ID
   */
  async stopDeployment(deploymentId) {
    if (!this.deploymentIntegration) {
      throw new Error('Deployment integration not initialized');
    }

    const result = await this.deploymentIntegration.stop({
      deploymentId: deploymentId || this.deploymentResult?.id,
      graceful: true
    });

    if (result.success) {
      this.codeAgent.emit('info', {
        phase: 'deployment',
        message: 'üõë Deployment stopped successfully'
      });
    }

    return result;
  }

  /**
   * Remove deployment
   * @param {string} deploymentId - Deployment ID
   */
  async removeDeployment(deploymentId) {
    if (!this.deploymentIntegration) {
      throw new Error('Deployment integration not initialized');
    }

    const result = await this.deploymentIntegration.remove({
      deploymentId: deploymentId || this.deploymentResult?.id,
      cleanup: true
    });

    if (result.success) {
      this.codeAgent.emit('info', {
        phase: 'deployment',
        message: 'üóëÔ∏è Deployment removed successfully'
      });
    }

    return result;
  }
}

export { DeploymentPhase };