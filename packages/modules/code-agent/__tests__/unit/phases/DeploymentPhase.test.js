/**
 * Unit tests for DeploymentPhase
 */

import { jest } from '@jest/globals';
import { DeploymentPhase } from '../../../src/agent/phases/DeploymentPhase.js';

describe('DeploymentPhase', () => {
  let deploymentPhase;
  let mockCodeAgent;
  let mockDeploymentIntegration;

  beforeEach(() => {
    // Create mock code agent
    mockCodeAgent = {
      emit: jest.fn(),
      config: {
        workingDirectory: '/test/project',
        deployment: {
          provider: 'local',
          enabled: true
        }
      },
      projectPlan: {
        projectName: 'test-app',
        description: 'Test application'
      },
      generatedFiles: new Set(['index.js', 'app.js', 'test.js']),
      fileOps: {
        exists: jest.fn(),
        writeFile: jest.fn()
      }
    };

    // Create mock deployment integration
    mockDeploymentIntegration = {
      initialize: jest.fn().mockResolvedValue(undefined),
      getSupportedProviders: jest.fn().mockResolvedValue(['local', 'docker', 'railway']),
      deploy: jest.fn().mockResolvedValue({
        success: true,
        id: 'deploy-123',
        provider: 'local',
        url: 'http://localhost:3000',
        status: 'running'
      }),
      monitor: jest.fn().mockResolvedValue({
        health: { status: 'healthy' }
      }),
      getLogs: jest.fn().mockResolvedValue({
        success: true,
        logs: ['App started', 'Listening on port 3000']
      }),
      stop: jest.fn().mockResolvedValue({ success: true }),
      remove: jest.fn().mockResolvedValue({ success: true })
    };

    deploymentPhase = new DeploymentPhase(mockCodeAgent);
  });

  describe('initialize', () => {
    it('should initialize deployment integration', async () => {
      await deploymentPhase.initialize(mockDeploymentIntegration);
      
      expect(deploymentPhase.deploymentIntegration).toBe(mockDeploymentIntegration);
      expect(mockDeploymentIntegration.initialize).toHaveBeenCalled();
    });
  });

  describe('deployApplication', () => {
    beforeEach(async () => {
      await deploymentPhase.initialize(mockDeploymentIntegration);
    });

    it('should deploy application successfully', async () => {
      mockCodeAgent.fileOps.exists.mockResolvedValue(true);

      const result = await deploymentPhase.deployApplication({
        provider: 'local',
        name: 'my-app'
      });

      expect(result.success).toBe(true);
      expect(result.deploymentId).toBe('deploy-123');
      expect(result.provider).toBe('local');
      expect(result.url).toBe('http://localhost:3000');
      
      expect(mockDeploymentIntegration.deploy).toHaveBeenCalledWith({
        projectPath: '/test/project',
        provider: 'local',
        name: 'my-app',
        config: expect.objectContaining({
          env: {},
          port: 3000,
          healthCheckPath: '/health'
        })
      });
    });

    it('should handle deployment failure', async () => {
      mockDeploymentIntegration.deploy.mockResolvedValue({
        success: false,
        error: 'Connection refused'
      });

      const result = await deploymentPhase.deployApplication();

      expect(result.success).toBe(false);
      expect(result.error).toBe('Connection refused');
      expect(mockCodeAgent.emit).toHaveBeenCalledWith('error', expect.objectContaining({
        phase: 'deployment',
        message: expect.stringContaining('Connection refused')
      }));
    });

    it('should validate deployment configuration', async () => {
      mockDeploymentIntegration.getSupportedProviders.mockResolvedValue(['local']);

      const result = await deploymentPhase.deployApplication({
        provider: 'unsupported'
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('Unsupported provider');
    });

    it('should generate package.json if missing', async () => {
      mockCodeAgent.fileOps.exists.mockResolvedValue(false);

      await deploymentPhase.deployApplication();

      expect(mockCodeAgent.fileOps.writeFile).toHaveBeenCalledWith(
        '/test/project/package.json',
        expect.stringContaining('"name": "test-app"')
      );
    });

    it('should generate Dockerfile for Docker deployments', async () => {
      mockCodeAgent.fileOps.exists.mockResolvedValue(false);

      await deploymentPhase.deployApplication({
        provider: 'docker',
        autoGenerateDockerfile: true
      });

      expect(mockCodeAgent.fileOps.writeFile).toHaveBeenCalledWith(
        '/test/project/Dockerfile',
        expect.stringContaining('FROM')
      );
    });

    it('should monitor deployment if enabled', async () => {
      mockCodeAgent.fileOps.exists.mockResolvedValue(true);

      await deploymentPhase.deployApplication({
        monitor: true
      });

      expect(mockDeploymentIntegration.monitor).toHaveBeenCalledWith({
        deploymentId: 'deploy-123',
        duration: 30000,
        interval: 5000
      });
    });
  });

  describe('getDeploymentLogs', () => {
    beforeEach(async () => {
      await deploymentPhase.initialize(mockDeploymentIntegration);
    });

    it('should retrieve deployment logs', async () => {
      const result = await deploymentPhase.getDeploymentLogs('deploy-123', {
        lines: 50
      });

      expect(result.success).toBe(true);
      expect(result.logs).toHaveLength(2);
      expect(mockDeploymentIntegration.getLogs).toHaveBeenCalledWith({
        deploymentId: 'deploy-123',
        lines: 50,
        follow: false
      });
    });

    it('should throw error if integration not initialized', async () => {
      deploymentPhase.deploymentIntegration = null;

      await expect(deploymentPhase.getDeploymentLogs('deploy-123'))
        .rejects.toThrow('Deployment integration not initialized');
    });
  });

  describe('stopDeployment', () => {
    beforeEach(async () => {
      await deploymentPhase.initialize(mockDeploymentIntegration);
    });

    it('should stop deployment successfully', async () => {
      const result = await deploymentPhase.stopDeployment('deploy-123');

      expect(result.success).toBe(true);
      expect(mockDeploymentIntegration.stop).toHaveBeenCalledWith({
        deploymentId: 'deploy-123',
        graceful: true
      });
      expect(mockCodeAgent.emit).toHaveBeenCalledWith('info', expect.objectContaining({
        message: '🛑 Deployment stopped successfully'
      }));
    });
  });

  describe('removeDeployment', () => {
    beforeEach(async () => {
      await deploymentPhase.initialize(mockDeploymentIntegration);
    });

    it('should remove deployment successfully', async () => {
      const result = await deploymentPhase.removeDeployment('deploy-123');

      expect(result.success).toBe(true);
      expect(mockDeploymentIntegration.remove).toHaveBeenCalledWith({
        deploymentId: 'deploy-123',
        cleanup: true
      });
      expect(mockCodeAgent.emit).toHaveBeenCalledWith('info', expect.objectContaining({
        message: '🗑️ Deployment removed successfully'
      }));
    });
  });

  describe('_findMainFile', () => {
    it('should find main entry file from generated files', () => {
      mockCodeAgent.generatedFiles = new Set([
        'components/Header.js',
        'utils/helpers.js',
        'index.js'
      ]);

      const mainFile = deploymentPhase._findMainFile();
      expect(mainFile).toBe('index.js');
    });

    it('should default to index.js if no common entry found', () => {
      mockCodeAgent.generatedFiles = new Set(['helper.js', 'utils.js']);

      const mainFile = deploymentPhase._findMainFile();
      expect(mainFile).toBe('helper.js');
    });
  });

  describe('_determineStartScript', () => {
    it('should use node for backend projects', () => {
      mockCodeAgent.config.projectType = 'backend';
      const script = deploymentPhase._determineStartScript();
      expect(script).toContain('node');
    });

    it('should use http server for frontend projects', () => {
      mockCodeAgent.config.projectType = 'frontend';
      const script = deploymentPhase._determineStartScript();
      expect(script).toContain('http-server');
    });
  });

  describe('_extractDependencies', () => {
    it('should detect express dependency', () => {
      mockCodeAgent.generatedFiles = new Set(['app.js']);
      mockCodeAgent.fileOps.exists = jest.fn().mockImplementation(path => 
        path.includes('app.js')
      );

      const deps = deploymentPhase._extractDependencies();
      expect(deps).toHaveProperty('express');
    });

    it('should include custom dependencies from config', () => {
      deploymentPhase.deploymentConfig = {
        dependencies: {
          'custom-lib': '^1.0.0'
        }
      };

      const deps = deploymentPhase._extractDependencies();
      expect(deps).toHaveProperty('custom-lib', '^1.0.0');
    });
  });
});