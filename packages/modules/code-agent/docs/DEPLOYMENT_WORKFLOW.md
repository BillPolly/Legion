# Deployment Workflow Documentation

## Overview

The Code Agent now includes integrated deployment capabilities, allowing generated applications to be automatically deployed to various providers including local processes, Docker containers, and Railway cloud platform. This document describes the deployment workflow, architecture, and usage patterns.

## Architecture

### Component Overview

The deployment functionality is implemented through several key components:

1. **DeploymentPhase** (`src/agent/phases/DeploymentPhase.js`)
   - Manages the deployment workflow as part of the agent's phase system
   - Validates deployment configurations
   - Prepares applications for deployment (generates package.json, Dockerfile, etc.)
   - Handles deployment lifecycle (deploy, monitor, stop, remove)

2. **DeploymentIntegration** (`src/integration/DeploymentIntegration.js`)
   - Integrates `@jsenvoy/conan-the-deployer` module
   - Manages module loading and initialization
   - Provides abstraction layer for deployment operations
   - Tracks active deployments

3. **CodeAgent Updates** (`src/agent/CodeAgent.js`)
   - Added deployment phase to workflow
   - New deployment configuration options
   - Deployment lifecycle methods

4. **Module Interface** (`module.json`)
   - New `deploy_generated_code` tool for external access
   - Deployment configuration schema
   - Provider and configuration options

## Deployment Workflow

### 1. Initialization

When deployment is enabled, the CodeAgent initializes the deployment phase:

```javascript
// CodeAgent constructor
if (this.config.deployment?.enabled) {
  this.deploymentPhase = new DeploymentPhase(this);
}

// During development workflow
if (this.deploymentPhase) {
  await this.deploymentPhase.initialize(this.deploymentIntegration);
}
```

### 2. Automatic Deployment

When `deploy: true` is passed to the `develop()` method:

```javascript
const result = await agent.develop({
  projectName: 'My App',
  description: 'A web application',
  deploy: true  // Triggers automatic deployment
});
```

The deployment occurs after successful code generation and quality validation.

### 3. Manual Deployment

Applications can be deployed separately using:

```javascript
// Via CodeAgent instance
const deployResult = await agent.deployApplication({
  provider: 'docker',
  name: 'my-app',
  environment: {
    NODE_ENV: 'production'
  }
});

// Via module tool
const result = await codeAgentModule.deployGeneratedCode({
  workingDirectory: './my-project',
  provider: 'railway',
  config: {
    railwayProjectId: 'existing-project-id'
  }
});
```

## Deployment Providers

### Local Provider
- Runs applications as local Node.js processes
- Suitable for development and testing
- Automatic port assignment
- Process management

### Docker Provider
- Containerizes applications
- Auto-generates Dockerfile if missing
- Supports custom Dockerfile paths
- Port mapping and environment configuration

### Railway Provider
- Cloud deployment platform
- Requires `RAILWAY_API_TOKEN` environment variable
- Supports existing project deployment
- Production-ready hosting

## Configuration Options

### Agent-Level Configuration

```javascript
const agent = new CodeAgent({
  deployment: {
    enabled: true,              // Enable deployment features
    provider: 'docker',         // Default provider
    autoCleanup: false,         // Cleanup on agent destroy
    defaultPort: 3000,          // Default application port
    healthCheckPath: '/health'  // Health check endpoint
  }
});
```

### Deployment-Specific Configuration

```javascript
await agent.deployApplication({
  provider: 'docker',
  name: 'my-api',
  config: {
    port: 8080,
    environment: {
      DATABASE_URL: 'postgresql://...',
      REDIS_URL: 'redis://...'
    },
    dockerfile: './custom.dockerfile',
    autoGenerateDockerfile: true,
    monitor: true,
    monitorDuration: 60000
  }
});
```

## Deployment Preparation

### Package.json Generation

If missing, the deployment phase generates a `package.json`:
- Extracts dependencies from code analysis
- Sets appropriate start scripts
- Configures Node.js engine version
- Adds necessary dev dependencies

### Dockerfile Generation

For Docker deployments without existing Dockerfile:
- Multi-stage build for optimization
- Appropriate base images (Node.js for backend, nginx for frontend)
- Security best practices
- Health check configuration

## Monitoring and Management

### Health Monitoring

```javascript
const health = await agent.deploymentPhase.monitor({
  deploymentId: 'deploy-123',
  duration: 30000,
  interval: 5000
});
```

### Deployment Logs

```javascript
const logs = await agent.deploymentPhase.getDeploymentLogs('deploy-123', {
  lines: 100,
  follow: false
});
```

### Lifecycle Management

```javascript
// Stop deployment gracefully
await agent.deploymentPhase.stopDeployment('deploy-123');

// Remove deployment and cleanup
await agent.deploymentPhase.removeDeployment('deploy-123');
```

## Integration with jsEnvoy Ecosystem

The deployment functionality integrates seamlessly with:

1. **Module Loader**: Uses `@jsenvoy/module-loader` for dynamic loading
2. **Resource Manager**: Shares resources across modules
3. **Conan-the-Deployer**: Provides deployment implementation
4. **Railway Module**: Optional Railway-specific features

## Error Handling

The deployment phase includes comprehensive error handling:

1. **Validation Errors**: Invalid configurations, missing requirements
2. **Deployment Failures**: Port conflicts, build errors, connection issues
3. **Runtime Errors**: Application crashes, health check failures
4. **Provider Errors**: API failures, authentication issues

Errors are propagated with context:
```javascript
{
  success: false,
  error: 'Port 3000 already in use',
  errorCode: 'DEPLOYMENT_FAILED',
  provider: 'local',
  details: { ... }
}
```

## Best Practices

1. **Development Workflow**
   - Use local provider for development
   - Enable monitoring during initial deployments
   - Check logs if deployment fails

2. **Production Deployment**
   - Use Railway or Docker for production
   - Configure proper environment variables
   - Set up health checks
   - Monitor deployment status

3. **Resource Management**
   - Clean up unused deployments
   - Use `autoCleanup` for temporary deployments
   - Monitor resource usage

4. **Security**
   - Never commit API keys or secrets
   - Use environment variables for sensitive data
   - Configure proper access controls

## Example Workflows

### Full Development to Deployment

```javascript
// Create agent with deployment enabled
const agent = new CodeAgent({
  deployment: {
    enabled: true,
    provider: 'docker'
  }
});

// Initialize in project directory
await agent.initialize('./my-app');

// Develop and deploy automatically
const result = await agent.develop({
  projectName: 'Todo API',
  description: 'REST API for todo management',
  requirements: {
    backend: 'Express API with CRUD operations',
    features: ['Authentication', 'Database persistence']
  },
  deploy: true
});

console.log(`Application deployed at: ${result.deployment.url}`);
```

### Deploy Existing Project

```javascript
// Deploy previously generated code
const agent = new CodeAgent({
  deployment: { enabled: true }
});

await agent.initialize('./existing-project');

const deployment = await agent.deployApplication({
  provider: 'railway',
  environment: {
    NODE_ENV: 'production',
    API_KEY: process.env.API_KEY
  }
});
```

### Multi-Stage Deployment

```javascript
// Development deployment
const devDeploy = await agent.deployApplication({
  provider: 'local',
  name: 'app-dev',
  config: { port: 3000 }
});

// Run tests against deployment
// ... test code ...

// Production deployment
const prodDeploy = await agent.deployApplication({
  provider: 'railway',
  name: 'app-prod',
  config: {
    environmentName: 'production',
    healthCheckPath: '/api/health'
  }
});
```

## Troubleshooting

### Common Issues

1. **Module Loading Failures**
   - Ensure `@jsenvoy/conan-the-deployer` is installed
   - Check module path resolution
   - Verify ResourceManager initialization

2. **Deployment Failures**
   - Check provider-specific requirements (Docker daemon, API keys)
   - Verify port availability
   - Review application logs

3. **Runtime Errors**
   - Monitor deployment health
   - Check environment variables
   - Review generated configuration files

### Debug Mode

Enable detailed logging:
```javascript
const agent = new CodeAgent({
  debug: true,
  deployment: {
    enabled: true,
    verbose: true
  }
});
```

## Future Enhancements

Potential improvements to the deployment workflow:

1. **Additional Providers**
   - Kubernetes deployment
   - AWS/GCP/Azure integration
   - Vercel/Netlify for frontend

2. **Advanced Features**
   - Blue-green deployments
   - Automatic rollback
   - Performance monitoring
   - Cost tracking

3. **Developer Experience**
   - CLI deployment commands
   - Visual deployment status
   - Deployment templates
   - Multi-environment management