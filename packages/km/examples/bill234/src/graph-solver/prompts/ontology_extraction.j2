You are extracting entities and relationships from a financial document according to a specified ontology.

ONTOLOGY:
{{ ontology }}

DOCUMENT DATA:
Example ID: {{ example_id }}

Table:
{{ table | tojson(indent=2) }}

Knowledge Base:
{{ knowledge_base | tojson(indent=2) }}

{% if extraction_mode == "table_only" %}
EXTRACTION MODE: TABLE ONLY
============================
**CRITICAL**: Extract metrics ONLY from the TABLE above.
- IGNORE all metrics mentioned in knowledge_base.text_content
- You can see the text for context, but DO NOT extract from it
- This pass focuses exclusively on structured table data

**FOOTNOTE PROCESSING (CRITICAL FOR TABLE METRICS):**
When extracting table metrics, check knowledge_base.text_content for footnotes that DEFINE what table columns/rows represent.

Common footnote patterns to look for:
- "(a) represents [definition]"
- "(1) indicates [definition]"
- "* denotes [definition]"
- "[symbol] = [definition]"

If a table metric has a footnote reference (letters, numbers, or symbols in parentheses or as superscripts):
1. Look for the corresponding footnote in knowledge_base.text_content
2. Extract the footnote explanation
3. Add it as a `comment` field on the FinancialMetric entity

Example:
- Table row/column: "outstanding balance ( a )"
- Footnote in text: "(a) represents the sum of contractual principal, interest and fees earned at the reporting date"
- Add to metric JSON: `"comment": "Represents the sum of contractual principal, interest and fees earned at the reporting date"`

This comment helps later stages understand what the metric semantically represents, enabling better question-to-metric matching!

{% elif extraction_mode == "text_only" %}
EXTRACTION MODE: TEXT ONLY
============================
**CRITICAL**: Extract metrics ONLY from knowledge_base.text_content.
- IGNORE all metrics in the TABLE above
- You can see the table for context, but DO NOT extract from it
- This pass focuses exclusively on narrative text metrics
- Look for patterns like:
  * "we reported $X billion of [metric name] for fiscal [year]"
  * "[metric name] was $X million for [year]"
  * "authorized to issue X billion shares of [stock class]" (CAPACITY LIMIT)
  * "X shares outstanding" (CURRENT HOLDINGS)

{% endif %}

TASK:
Extract entities, values, and relationships from this financial document according to the ConvFinQA ontology.

CRITICAL RULES:

0. **üö® CRITICAL: CANONICAL VALUES WITH SCALE METADATA üö®**
   **THE MOST IMPORTANT RULE - READ THIS FIRST!**

   Store the ACTUAL NUMBER you see in text with its scale as metadata:
   - Text: "$4.5 million" ‚Üí numericValue: 4.5, scale: Millions
   - Text: "$10.5 billion" ‚Üí numericValue: 10.5, scale: Billions
   - Text: "$2.3 thousand" ‚Üí numericValue: 2.3, scale: Thousands

   ‚ùå WRONG: Converting to Units! "$4.5 million" ‚Üí 4500000.0 Units
   ‚úÖ CORRECT: Keep canonical! "$4.5 million" ‚Üí 4.5 Millions

   The numericValue field gets THE NUMBER FROM TEXT.
   The scale field gets THE SCALE WORD (Millions/Billions/Thousands/Units).
   DO NOT multiply the number by the scale factor!

1. **Every numeric value MUST be a FinancialValue entity** with explicit attributes
   - NOT: metric hasAmount 7200
   - YES: metric hasValue value_123; value_123 numericValue 7200, hasScale Units

2. **Choose the correct FinancialValue subclass:**
   - MonetaryValue: Dollar amounts (e.g., revenue, expenses)
   - PercentageValue: Percentages (e.g., 19%, 75%)
   - CountValue: Counts/quantities (e.g., 7200 vehicles)
   - RatioValue: Dimensionless ratios (e.g., 1.73)
   - IndexValue: Index values with baseline (e.g., 100.0 = 2015)

3. **Always extract scale for monetary values:**
   - If table says "in thousands" ‚Üí scale: Thousands
   - If table says "in millions" ‚Üí scale: Millions
   - If no scale mentioned ‚Üí scale: Units

4. **Create entities for:**
   - Company (from knowledge_base.entities or example_id)
   - FinancialMetric (each row in table, each extracted value from text)
   - Year (from column names or dates)
   - Category (column categories like "residential", "commercial")

4b. **EXTRACT METRICS FROM NARRATIVE TEXT (CRITICAL!):**
   - Check knowledge_base.text_content for financial statements in narrative form
   - Look for patterns like:
     * "we reported $X billion of [metric name] for fiscal [year]"
     * "[metric name] was $X million for [year]"
     * "as of [date], [metric name] totaled $X"
   - Extract these as FinancialMetric entities even if not in table
   - Example: "we reported $10.5 billion of consolidated net income for fiscal 2018"
     ‚Üí Create entity_Metric_NetIncome_2018 with value 10.5 billion
   - IMPORTANT: These metrics are JUST AS IMPORTANT as table metrics!
   - **CRITICAL: Store canonical values with scale metadata** - DO NOT convert to Units!
     * "$10.5 billion" = numericValue: 10.5, scale: Billions  (NOT 10500000000 Units!)
     * "$318 million" = numericValue: 318, scale: Millions  (NOT 318000000 Units!)
     * "$4.5 million" = numericValue: 4.5, scale: Millions  (NOT 4500000 Units!)
     * "$2.3 thousand" = numericValue: 2.3, scale: Thousands  (NOT 2300 Units!)
     * The numericValue should be THE NUMBER YOU SEE in the text, with scale indicating the magnitude!

5. **Link everything:**
   - Company hasMetric FinancialMetric
   - FinancialMetric hasValue FinancialValue
   - FinancialMetric forTimePeriod Year
   - FinancialMetric inCategory Category (if applicable)

6. **Preserve table structure:**
   - Add tableRow and tableColumn attributes to FinancialMetric
   - This helps with query generation later

OUTPUT FORMAT:
Return a JSON object with this structure:

{
  "entities": [
    {
      "id": "entity_Company_RepublicServices",
      "type": "Company",
      "label": "Republic Services"
    },
    {
      "id": "entity_Metric_ResidentialVehicles_2017",
      "type": "FinancialMetric",
      "label": "Approximate number of vehicles - Residential",
      "tableRow": "approximate number of vehicles",
      "tableColumn": "residential"
    },
    {
      "id": "entity_Year_2017",
      "type": "Year",
      "yearValue": 2017,
      "label": "2017"
    },
    {
      "id": "entity_Category_Residential",
      "type": "Category",
      "label": "Residential"
    }
  ],
  "values": [
    {
      "id": "value_ResidentialVehicles_2017",
      "type": "CountValue",
      "numericValue": 7200,
      "scale": "Units",
      "displayValue": "7200",
      "metricName": "Approximate number of vehicles",
      "tableRow": "approximate number of vehicles",
      "tableColumn": "residential",
      "year": "2017"
    },
    {
      "id": "value_CNGFleetPercentage",
      "type": "PercentageValue",
      "numericValue": 19,
      "scale": "Units",
      "displayValue": "19%",
      "metricName": "Percentage of CNG fleet",
      "label": "percentage of fleet that operates on cng"
    }
  ],
  "relationships": [
    {
      "subject": "entity_Company_RepublicServices",
      "predicate": "hasMetric",
      "object": "entity_Metric_ResidentialVehicles_2017"
    },
    {
      "subject": "entity_Metric_ResidentialVehicles_2017",
      "predicate": "hasValue",
      "object": "value_ResidentialVehicles_2017"
    },
    {
      "subject": "entity_Metric_ResidentialVehicles_2017",
      "predicate": "forTimePeriod",
      "object": "entity_Year_2017"
    },
    {
      "subject": "entity_Metric_ResidentialVehicles_2017",
      "predicate": "inCategory",
      "object": "entity_Category_Residential"
    }
  ]
}

**CRITICAL: Make FinancialValue Objects Self-Describing**

Each value object MUST include metadata from its parent metric so it's completely self-describing:

For TABLE METRICS:
- `metricName`: Human-readable metric name
- `tableRow`: The row label from the table
- `tableColumn`: The column label from the table
- `year`: Extracted from column if it's a year (e.g., "2015", "2014")

For EXTRACTED METRICS:
- `metricName`: Human-readable metric name
- `label`: The metric label
- `year`: Year from the metric name if applicable

Example table value:
```json
{
  "id": "value_TotalDebt_2015",
  "type": "MonetaryValue",
  "numericValue": 1762.3,
  "scale": "Millions",
  "displayValue": "1762.3",
  "metricName": "Total debt",
  "tableRow": "total debt",
  "tableColumn": "december 31 , 2015",
  "year": "2015"
}
```

Example extracted value from narrative text:
```json
{
  "id": "value_NetIncome_2018",
  "type": "MonetaryValue",
  "numericValue": 10.5,
  "scale": "Billions",
  "displayValue": "$10.5 billion",
  "metricName": "Consolidated net income",
  "label": "consolidated net income for fiscal 2018",
  "year": "2018"
}
```

**CRITICAL REMINDER - Canonical Values:**
If text says "approximately $4.5 million was capitalized":
```json
{
  "id": "value_CapitalizedAmount_2013",
  "type": "MonetaryValue",
  "numericValue": 4.5,           ‚Üê THE NUMBER FROM TEXT (4.5, not 4500000!)
  "scale": "Millions",            ‚Üê THE SCALE FROM TEXT
  "displayValue": "$4.5 million",
  "metricName": "Capitalized amount"
}
```

CRITICAL EXAMPLE - Text Extraction:
If knowledge_base.text_content contains:
"we reported $10.5 billion and $14.3 billion of consolidated net income for fiscal 2018 and 2017"

You MUST create TWO FinancialMetric entities:
1. entity_Metric_NetIncome_2018 with value_NetIncome_2018 (10.5, Billions)
2. entity_Metric_NetIncome_2017 with value_NetIncome_2017 (14.3, Billions)

These are CRITICAL for answering questions that reference metrics not in the table!

IMPORTANT NAMING CONVENTIONS:
- Entity IDs: "entity_{Type}_{DescriptiveName}" (e.g., "entity_Metric_NetIncome_2012")
- Value IDs: "value_{DescriptiveName}" (e.g., "value_NetIncome_2012")
- Use consistent, descriptive names
- No special characters in IDs (use underscores)

For TABLE DATA - Handle BOTH formats:

FORMAT 1 (Column-first): Table dict has COLUMN names as keys
Example: {"2005": {"net cash used": -3679.0, ...}, "2004": {"net cash used": -2534.0}}
- Each top-level key is a COLUMN (year/category)
- Each nested key is a ROW (metric name)
- tableColumn = top-level key, tableRow = nested key

FORMAT 2 (Row-first): Table dict has ROW names as keys
Example: {"total shares purchased": {"october 1-31": 2099169.0, "total": 4823020.0}}
- Each top-level key is a ROW (metric name)
- Each nested key is a COLUMN (period/category)
- tableRow = top-level key, tableColumn = nested key

**How to detect which format:**
- If top-level keys look like years ("2005", "2004") or broad categories ("residential", "commercial") ‚Üí FORMAT 1
- If top-level keys look like metric names ("total shares purchased", "net income") ‚Üí FORMAT 2

**For both formats:**
- Create ONE FinancialMetric entity per cell that has a value
- Set tableRow and tableColumn appropriately
- Link to appropriate Year or Category entities

For EXTRACTED VALUES from knowledge_base:
- These come from text analysis, not the table
- **CRITICAL**: Each key in knowledge_base is a SEPARATE metric entity!
  - Keys with year suffixes (e.g., "sublease_revenues_2007", "sublease_revenues_2008") are DIFFERENT entities
  - Create ONE FinancialMetric entity per knowledge_base key
  - If key has year suffix (_2006, _2007, _2008), extract year and create forTimePeriod relationship
  - Example: "sublease_revenues_2007": 7.7 ‚Üí Create entity_Metric_SubleaseRevenues_2007 linked to entity_Year_2007
  - Example: "sublease_revenues_2008": 7.1 ‚Üí Create entity_Metric_SubleaseRevenues_2008 linked to entity_Year_2008
- Include sourceText in metadata if helpful for validation

Return ONLY the JSON object, no additional text.
